package net.exploitables.audy.theory_tests;

import static org.junit.Assert.assertTrue;

import org.junit.Ignore;
import org.junit.Test;

import java.util.*;

/**
 * Test speeds between a HashMap, a List, a Set, and an Array. Big O notation doesn't represent actual speeds so I would like
 *  to compare speeds within the JVM itself.
 *
 * The CommandProcessor needs to search through the CommandTree to find needed commands, however I do wonder if the
 *  calculation time required for a hash exceeds the time needed to just get the first/second/third entry in a list or
 *  array.
 *
 * After testing, it seems that:
 *      1 entry shows the array to be faster
 *      3 entries shows the map to be faster
 *      10 entries shows the map to be faster
 *
 * Since most of the time I plan to have at least three sub-commands using a map seems to be most optimal.
 * Excluding and possible custom data structures of course.
 *
 * Not exactly the reason tests exist, however placing this here for easy access if needed later.
 */
public class MapVsList
{
    static class FauxNode {
        String key;

        public FauxNode(String key) {
            this.key = key;
        }
    }

    @Test
    @Ignore("This test doesn't ensure functionality, only used as a point of reference")
    public void testSpeeds() {
        // Amount of times to randomly access each data structure
        int randomAccessCount = 1000000;
        // Test keys to use when creating the FauxNodes
        String[] keys = {"add", "subtract", "multiply", "divide", "list", "show", "ban", "kick", "about", ":^)"};

        // Assuming that since Java variables are "all pointers" in laymans terms, I don't think there will be a
        // performance penalty when using a larger data type for the value within the map
        HashMap<String, FauxNode> testMap = new HashMap<>();
        // Might be possible to pre-optimize the order of what is being accessed based on usage frequency
        // however that would need usage statistics and I think would be a lot of change for little performance
        List<FauxNode> testList = new ArrayList<>();
        Set<FauxNode> testSet = new HashSet<>();
        FauxNode[] testArray = new FauxNode[keys.length];

        // Populate test data structures
        long populateStart = System.nanoTime();
        for (int i = 0; i < keys.length; i++) {
            String key = keys[i];
            FauxNode newNode = new FauxNode(key);
            testMap.put(key, newNode);
            testList.add(newNode);
            testSet.add(newNode);
            testArray[i] = newNode;
        }
        long populateEnd = System.nanoTime();
        System.out.println("Time taken to populate: " + (populateEnd - populateStart) + " nanoseconds");

        Random random = new Random();

        // testMap
        long mapStart = System.nanoTime();
        for (int i = 0; i < randomAccessCount; i++) {
            int randInt = random.nextInt(keys.length);
            FauxNode pulledNode = testMap.get(keys[randInt]);
        }
        long mapEnd = System.nanoTime();
        System.out.println("Time taken for map: " + (mapEnd - mapStart) + " nanoseconds");

        // testList
        long listStart = System.nanoTime();
        for (int i = 0; i < randomAccessCount; i++) {
            int randInt = random.nextInt(keys.length);
            String key = keys[randInt];
            FauxNode pulledNode;
            for (FauxNode node : testList) {
                if (node.key.equals(key)) {
                    //noinspection UnusedAssignment
                    pulledNode = node;
                    break;
                }
            }
        }
        long listEnd = System.nanoTime();
        System.out.println("Time taken for list: " + (listEnd - listStart) + " nanoseconds");

        // testSet
        long setStart = System.nanoTime();
        for (int i = 0; i < randomAccessCount; i++) {
            int randInt = random.nextInt(keys.length);
            String key = keys[randInt];
            FauxNode pulledNode;
            for (FauxNode node : testSet) {
                if (node.key.equals(key)) {
                    //noinspection UnusedAssignment
                    pulledNode = node;
                    break;
                }
            }
        }
        long setEnd = System.nanoTime();
        System.out.println("Time taken for set: " + (setEnd - setStart) + " nanoseconds");

        // testArray
        long arrayStart = System.nanoTime();
        for (int i = 0; i < randomAccessCount; i++) {
            int randInt = random.nextInt(keys.length);
            String key = keys[randInt];
            FauxNode pulledNode;
            for (FauxNode node : testArray) {
                if (node.key.equals(key)) {
                    //noinspection UnusedAssignment
                    pulledNode = node;
                    break;
                }
            }
        }
        long arrayEnd = System.nanoTime();
        System.out.println("Time taken for array: " + (arrayEnd - arrayStart) + " seconds");

        assertTrue(true);
    }
}
