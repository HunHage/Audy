/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.utilities;

import discord4j.common.util.Snowflake;
import org.joda.time.*;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import java.time.Instant;

public class TimeFormatter {
    private static DateTimeFormatter dateTimeFormat = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss.SSS zzz");
    private static DateTimeFormatter dateTimeFormatFilename = DateTimeFormat.forPattern("yyyy-MM-dd_HH-mm-ss-SSS_zzz");

    private static final int DAY_IN_MILLIS = 86400000; // 24 * 60 * 60 * 1000
    private static final int HOUR_IN_MILLIS = 3600000; // 60 * 60 * 1000
    private static final int MINUTE_IN_MILLIS = 60000; // 60 * 1000
    private static final int SECOND_IN_MILLIS = 1000;  // 1000

    /**
     * Format a given snowflake into a standard date/time format
     * @param snowflake the ID of a discord entity
     * @return a string with the creation time formatted into a y/m/d h/m/s format
     */
    public static String format(Snowflake snowflake) {
        return dateTimeFormat.print(snowflake.getTimestamp().toEpochMilli());
    }

    /**
     * @param instant any instant
     * @return a string with the time formatted into a y/m/d h/m/s format
     */
    public static String format(Instant instant) {
        return dateTimeFormat.print(instant.toEpochMilli());
    }

    /**
     * @param dateTime a JodaTime DateTime
     * @return a string with the date and time formatted into a y/m/d h/m/s format
     */
    public static String format(DateTime dateTime) {
        return dateTimeFormat.print(dateTime);
    }

    /**
     * Format a given snowflake into a standard date/time format, and convert it to the UTC timezone
     * @param snowflake the ID of a discord entity
     * @return a string with the creation time formatted into a y/m/d h/m/s format in the UTC timezone
     */
    public static String formatUTC(Snowflake snowflake) {
        return dateTimeFormat.print(new DateTime(snowflake.getTimestamp().toEpochMilli()).withZone(DateTimeZone.UTC));
    }

    /**
     * @param instant any instant
     * @return a string with the time formatted into a y/m/d h/m/s format in the UTC timezone
     */
    public static String formatUTC(Instant instant) {
        return dateTimeFormat.print(new DateTime(instant.toEpochMilli()).withZone(DateTimeZone.UTC));
    }

    /**
     * @param dateTime a JodaTime DateTime
     * @return a string with the date and time formatted into a y/m/d h/m/s format
     */
    public static String formatUTC(DateTime dateTime) {
        return dateTimeFormat.print(dateTime.withZone(DateTimeZone.UTC));
    }

    /**
     * @return a string with the current date and time formatted into a y/m/d h/m/s format
     */
    public static String formatNowUTC() {
        return dateTimeFormat.print(DateTime.now().withZone(DateTimeZone.UTC));
    }

    /**
     * @return a filename friendly string with the current date and time formatted into a y/m/d h/m/s format
     */
    public static String formatNowFilenameUTC() {
        return dateTimeFormatFilename.print(DateTime.now().withZone(DateTimeZone.UTC)).replaceAll(" ", "_");
    }

    /**
     * @param instant the time to measure the age of
     * @return a string of the age formatted in a y/m/d/h/m and total day format
     */
    public static String formatAge(Instant instant) {
        // Add info on join date and account age
        DateTime today = DateTime.now();
        System.out.println(today.toDate().toString());
        DateTime created = org.joda.time.Instant.ofEpochMilli(instant.toEpochMilli()).toDateTime();
        int years, months, days, hours, minutes, seconds, totDays;
        totDays = Days.daysBetween(created, today).getDays();
        years   = Years.yearsBetween(created, today).getYears();
        created = created.plus(Years.years(years));
        months  = Months.monthsBetween(created, today).getMonths();
        created = created.plus(Months.months(months));
        days    = Days.daysBetween(created, today).getDays();
        created = created.plus(Days.days(days));
        hours   = Hours.hoursBetween(created, today).getHours();
        created = created.plus(Hours.hours(hours));
        minutes = Minutes.minutesBetween(created, today).getMinutes();
        //created = created.plus(Minutes.minutes(minutes));
        //seconds = Seconds.secondsBetween(created, today).getSeconds();

        return years +      "y " +
                months +    "m " +
                days +      "d " +
                hours +     "h " +
                minutes +   "m / " +
                //seconds + "s / "
                totDays +   "d";
    }

    /**
     * @param milliseconds the length of time to convert to a days/hours/minutes format
     * @return a string in the format of 0d0h0m representing the time passed
     */
    public static String formatDaysHoursMinutesAge(long milliseconds) {
        long days, hours, minutes;
        days          = milliseconds / DAY_IN_MILLIS;
        milliseconds -= (days * DAY_IN_MILLIS);
        hours         = milliseconds / HOUR_IN_MILLIS;
        milliseconds -= (hours * HOUR_IN_MILLIS);
        minutes       = milliseconds / MINUTE_IN_MILLIS;

        String content = "";
        content += days + "d";
        content += hours + "h";
        content += minutes + "m";

        return content;
    }

    /**
     * @param from starting point in time
     * @param to ending point in time
     * @return a string of the age formatted with minutes (if present), seconds, and milliseconds as `0m 0.000s`
     */
    public static String formatSmallAge(Instant from, Instant to) {
        if (from == null || to == null) return "a time was null";
        long duration = to.toEpochMilli() - from.toEpochMilli();
        long minutes, seconds;
        minutes   = duration / MINUTE_IN_MILLIS;
        duration -= (minutes * MINUTE_IN_MILLIS);
        seconds   = duration / SECOND_IN_MILLIS;
        // At this point, there should only be milliseconds left in the duration

        String content = "";
        if (minutes > 0) {
            content += minutes + "m ";
        }
        content += seconds + "." + duration + "s";

        return content;
    }

    /**
     * Parse the given string for an amount of time, and convert it to milliseconds.
     * Accepted formats are a repeating pattern of: 1+ numbers followed by a single character specifying the amount
     *  of time. Example: 1w1d1h1m
     * Accepted time values are *w*eeks, *d*ays, *h*ours, and *m*inutes.
     *
     * @param timeTerm an expression to parse a duration of time from such as 1w2d3m4s
     * @return the time specified in the provided term as a unit of minutes, -1 when a parsing error occurs.
     */
    public static long parseTimeIntoMinutes(String timeTerm) {
        long total = 0;
        int mult = 0;
        StringBuilder tempNumber = new StringBuilder();
        for (char c : timeTerm.toCharArray()) {
            if (Character.isAlphabetic(c)) {
                switch (c) {
                    case 'm': mult =     1; break;
                    case 'h': mult =    60; break;
                    case 'd': mult =  1440; break;
                    case 'w': mult = 10080; break;
                    default:  return -1; // Parsing error
                }
                if (tempNumber.length() > 0) {
                    total += mult * Integer.parseInt(tempNumber.toString());
                    tempNumber = new StringBuilder();
                } else {
                    return -1;
                }
            } else if (Character.isDigit(c)) {
                tempNumber.insert(0, c);
            } else {
                return -1; // Parsing error
            }
        }

        return total;
    }
}
