/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.utilities;

import discord4j.common.util.Snowflake;
import discord4j.core.object.entity.Member;
import discord4j.core.object.entity.Role;
import discord4j.core.object.entity.User;
import discord4j.core.object.entity.channel.GuildChannel;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * You know what'd be cool? If only there was some kind of `NamedEntity` interface for D4J.
 * If only ...
 */
public class EntitySearch {
    /**
     * Regex for matching Discord Snowflake IDs, either just the ID or the ID within a mention.
     *
     * First capture group grabs the "ID prefix" which denotes the type of Snowflake:
     * <@1234567890>  - User/Member - `@`
     * <@&1234567890> - Role        - `@&`
     * <#1234567890>  - Channel     - `#`
     * 1234567890     - Anything    - ``
     *
     * The second capture group is the snowflake ID itself, however since these can be typed in manually
     * they can still be invalid IDs. This format does not ensure validity.
     */
    private static final Pattern snowflakeRegex = Pattern.compile("<*([@&#]*)([0-9]+)>*");

    /**
     * Regex for matching **full usernames**, as in the account name followed by the discriminator as it would
     *  normally appear when viewing a user's profile.
     *
     *  First capture group is the name itself, user names can have almost any character.
     *  Second capture group is just the `#` symbol, might be unnecessary to capture.
     *  Third capture group is the 4 digit discriminator.
     *
     *  Username#1234
     *
     *  This format doesn't ensure validity, especially in the case users try to copy/paste or type out fancy names.
     */
    private static final Pattern fullNameRegex = Pattern.compile("(.+)(#)([0-9]{4})");

    /**
     * Check if a string matches a snowflake. Capture group 2 will contain the snowflake if matches.
     * @param snowflake string to evaluate for a snowflake, can be either just numbers or a mention
     * @return a Matcher with the results
     */
    public static Matcher matchSnowflake(String snowflake) {
        return snowflakeRegex.matcher(snowflake);
    }

    /**
     * Check if a string matches a full discord username (name + discriminator)
     * @param username string to evaluate for a full username
     * @return a Matcher with the results
     */
    public static Matcher matchFullUsername(String username) {
        return fullNameRegex.matcher(username);
    }

    /**
     * Search through a list of users by by either their ID or name.
     *
     * First tries to match based on if the term is all numbers and first assumes the term is a Snowflake ID.
     * Since Snowflakes are very unique, and very unlikely to be an exact match for a username, they are checked for
     *  first. If there is a match between one user's name and another user's ID then that case cannot be reasonably
     *  avoided as there is no context for which is the right choice. However, we can assume that if a length of
     *  numbers is inserted it is very likely an ID.
     *
     * If no *single* user is found by ID, then attempt to search for names starting with the provided phrase, a check
     *  is done to see if the provided term is a full user name (name+discriminator) but only the name part is checked
     *  at first. If there are multiple results then another filter is applied for the discriminator if present.
     *
     * @param users A list of users or members to search through, normally sourced from a guild.
     * @param term the term to filter users by, can be a raw snowflake, a mention, a part of their name,
     *             or an exact match of its name with or without the discriminator attached.
     * @return a list with one user if a potential match is found, 0 or more than 1 users otherwise
     */
    public static <T extends User> List<T> searchUsersByTerm(List<T> users, String term) {
        List<T> results = new ArrayList<>();
        // Avoid returning the entire list of users when the term isn't present
        if (term.isEmpty()) return results;

        // Check if the term is a snowflake, note that users can set their name to be a bunch of numbers!
        Matcher matcher = snowflakeRegex.matcher(term);
        if (matcher.matches()) {
            // ignore snowflakes that do not belong to a user if passed by mention
            if (matcher.group(1).equals("@") || matcher.group(1).isEmpty()) {
                Snowflake id = Snowflake.of(matcher.group(2));
                results = users.stream()
                    .filter(user -> user
                        .getId()
                        .equals(id))
                    .collect(Collectors.toList());
                if (results.size() == 1) {
                    return results;
                }
            }
        }

        // See if we should try and search by full username
        matcher = fullNameRegex.matcher(term);
        // If no match then just assume the term is a partial name
        String username = term;
        if (matcher.matches()) { username = matcher.group(1); }
        username = username.toLowerCase();

        String finalUsername = username;
        results = users.stream()
            .filter(user -> user.getUsername()
                .toLowerCase()
                .startsWith(finalUsername))
            .collect(Collectors.toList());

        // Since we are searching for a single user, filter by ids now if possible
        // There has to be a better design to accomplish the logic here instead of chaining array iteration filters
        // But the amount of remaining users should be small (as long as a long enough term was used)
        if (results.size() > 1 && matcher.matches()) {
            String discriminator = matcher.group(2);
            results = results.stream()
                .filter(user -> user
                    .getDiscriminator()
                    .equals(discriminator))
                .collect(Collectors.toList());
        }

        // Final attempt, if there are still multiple results then make sure there are no edge cases where exact
        //  matches are missed, would try to simply go after the first exact match with regex or similar but then
        //  the edge case where two people have the exact same name arises ...
        if (results.size() > 1) {
            List<T> exactMatches = results.stream()
                .filter(user -> user
                    .getUsername()
                    .equalsIgnoreCase(finalUsername))
                .collect(Collectors.toList());
            if (exactMatches.size() > 0) {
                results = exactMatches;
            }
        }

        return results;
    }

    /**
     * Search through a list of users by by either their ID or name.
     * See searchUsersByTerm for additional documentation.
     *
     * First tries to search by user details alone, if a single result is found then return it.
     * If multiple (or zero) results are found then attempt a search based on the user's guild nickname.
     *
     * @param members A list of users to search through, normally sourced from a guild.
     * @param term the term to filter users by, can be a raw snowflake, a mention, a part of their name,
     *             or an exact match of its name with or without the discriminator attached
     * @return a list with one member if a potential match is found, 0 or more than 1 members otherwise
     */
    public static List<Member> searchMembersByTerm(List<Member> members, String term) {
        List<Member> results = new ArrayList<>(members);
        results = searchUsersByTerm(results, term);

        // Found a member based on user info, return
        if (results.size() == 1) {
            return results;
        }

        // Search guild nicknames, we don't attempt to filter by discriminators as it is likely redundant
        //  and improper formatting. I don't know where else something would show/accept nickname#discrimintator
        String lowerName = term.toLowerCase();
        results = members.stream()
            .filter(user -> user
                .getNickname()
                .map(nickname -> nickname.toLowerCase().startsWith(lowerName))
                .orElse(false))
            .collect(Collectors.toList());

        // If there are still multiple results then make sure there are no edge cases where exact matches are missed,
        //  would try to simply go after the first exact match however channels can have colliding names
        if (results.size() > 1) {
            List<Member> exactMatches = results.stream()
                .filter(member -> member
                    .getNickname()
                    .map(nickname -> nickname.equalsIgnoreCase(lowerName))
                    .orElse(false))
                .collect(Collectors.toList());
            if (exactMatches.size() > 0) {
                results = exactMatches;
            }
        }

        return results;
    }

    /**
     * Search through a list of channels by their ID or name.
     * See searchUsersByTerm for additional documentation.
     *
     * First tries to match based on if the term is all numbers and first assumes the term is a Snowflake ID.
     *
     * If no *single* channel is found by ID, then attempt to search for names starting with the provided phrase,
     *  if there are multiple results then filter again looking for an exact match.
     *
     * @param channels A list of guild channels to search through, normally sourced from a guild directly
     * @param term the term to filter channels by, can be a raw snowflake, a mention,
     *             a part of its name, or an exact match of its name
     * @return a list with one channel if a potential match is found, 0 or more than 1 channels otherwise
     */
    public static List<GuildChannel> searchGuildChannelsByTerm(List<GuildChannel> channels, String term) {
        List<GuildChannel> results = new ArrayList<>();
        // Avoid returning the entire list of channels when the term isn't present
        if (term.isEmpty()) return results;

        // Check if the term is a snowflake, note that channels can have their name set to be a bunch of numbers!
        Matcher matcher = snowflakeRegex.matcher(term);
        if (matcher.matches()) {
            // ignore snowflakes that do not belong to a channel if passed by mention
            if (matcher.group(1).equals("#") || matcher.group(1).isEmpty()) {
                Snowflake id = Snowflake.of(matcher.group(2));
                results = channels.stream()
                    .filter(channel -> channel
                        .getId()
                        .equals(id))
                    .collect(Collectors.toList());
                if (results.size() == 1) {
                    return results;
                }
            }
        }

        // Try and search by channel name
        String channelName = term.toLowerCase();
        results = channels.stream()
            .filter(channel -> channel.getName()
                .toLowerCase()
                .startsWith(channelName))
            .collect(Collectors.toList());

        // If there are still multiple results then make sure there are no edge cases where exact matches are missed,
        //  would try to simply go after the first exact match however channels can have colliding names
        if (results.size() > 1) {
            List<GuildChannel> exactMatches = results.stream()
                .filter(channel -> channel
                    .getName()
                    .equalsIgnoreCase(channelName))
                .collect(Collectors.toList());
            if (exactMatches.size() > 0) {
                results = exactMatches;
            }
        }

        return results;
    }

    /**
     * Search through a list of channels by their ID or name.
     * See searchUsersByTerm for additional documentation.
     *
     * First tries to match based on if the term is all numbers and first assumes the term is a Snowflake ID.
     *
     * If no *single* channel is found by ID, then attempt to search for names starting with the provided phrase,
     *  if there are multiple results then filter again looking for an exact match.
     *
     * @param roles A list of guild roles to search through, normally sourced from a guild directly
     * @param term the term to filter roles by, can be a raw snowflake, a mention,
     *             a part of its name, or an exact match of its name
     * @return a list with one channel if a potential match is found, 0 or more than 1 channels otherwise
     */
    public static List<Role> searchRolesByTerm(List<Role> roles, String term) {
        List<Role> results = new ArrayList<>();
        // Avoid returning the entire list of channels when the term isn't present
        if (term.isEmpty()) return results;

        // Check if the term is a snowflake, note that channels can have their name set to be a bunch of numbers!
        Matcher matcher = snowflakeRegex.matcher(term);
        if (matcher.matches()) {
            // ignore snowflakes that do not belong to a channel if passed by mention
            if (matcher.group(1).equals("@&") || matcher.group(1).isEmpty()) {
                Snowflake id = Snowflake.of(matcher.group(2));
                results = roles.stream()
                    .filter(role -> role
                        .getId()
                        .equals(id))
                    .collect(Collectors.toList());
                if (results.size() == 1) {
                    return results;
                }
            }
        }

        // Try and search by role name
        String roleName = term.toLowerCase();
        results = roles.stream()
            .filter(role -> role.getName()
                .toLowerCase()
                .startsWith(roleName))
            .collect(Collectors.toList());

        // If there are still multiple results then make sure there are no edge cases where exact matches are missed,
        //  would try to simply go after the first exact match however roles can have colliding names
        if (results.size() > 1) {
            List<Role> exactMatches = results.stream()
                .filter(role -> role
                    .getName()
                    .equalsIgnoreCase(roleName))
                .collect(Collectors.toList());
            if (exactMatches.size() > 0) {
                results = exactMatches;
            }
        }

        return results;
    }
}
