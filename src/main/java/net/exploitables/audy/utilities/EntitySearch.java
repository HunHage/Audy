/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.utilities;

import discord4j.common.util.Snowflake;
import discord4j.core.object.entity.Member;
import discord4j.core.object.entity.Role;
import discord4j.core.object.entity.User;
import discord4j.core.object.entity.channel.GuildChannel;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class EntitySearch {
    /**
     * Regex for matching Discord Snowflake IDs, either just the ID or the ID within a mention.
     *
     * First capture group grabs the "ID prefix" which denotes the type of Snowflake:
     * <@1234567890>  - User/Member - `@`
     * <@&1234567890> - Role        - `@&`
     * <#1234567890>  - Channel     - `#`
     * 1234567890     - Anything    - ``
     *
     * The second capture group is the snowflake ID itself, however since these can be typed in manually
     * they can still be invalid IDs. This format does not ensure validity.
     */
    private static final Pattern snowflakeRegex = Pattern.compile("<*([@&#]*)([0-9]+)>*");

    /**
     * Regex for matching **full usernames**, as in the account name followed by the discriminator as it would
     *  normally appear when viewing a user's profile.
     *
     *  First capture group is the name itself, user names can have almost any character.
     *  Second capture group is just the `#` symbol, might be unnecessary to capture.
     *  Third capture group is the 4 digit discriminator.
     *
     *  Username#1234
     *
     *  This format doesn't ensure validity, especially in the case users try to copy/paste or type out fancy names.
     */
    private static final Pattern fullNameRegex = Pattern.compile("(.+)(#)([0-9]{4})");

    /**
     * Check if a string matches a snowflake. Capture group 2 will contain the snowflake if matches.
     * @param snowflake string to evaluate for a snowflake, can be either just numbers or a mention
     * @return a Matcher with the results
     */
    public static Matcher matchSnowflake(String snowflake) {
        return snowflakeRegex.matcher(snowflake);
    }

    /**
     * Check if a string matches a full discord username (name + discriminator)
     * @param username string to evaluate for a full username
     * @return a Matcher with the results
     */
    public static Matcher matchFullUsername(String username) {
        return fullNameRegex.matcher(username);
    }

    /**
     * An interface to compare two objects with a custom method.
     * @param <T> any comparable class
     */
    private interface Compare<T> {
        boolean compare(T o1, T o2);
    }

    /**
     * A shortcut method to use with filterEntities to see if one string starts with another ignoring case.
     */
    private static boolean stringStartsWithIgnoreCase(String s1, String s2) {
        return s1.toLowerCase().startsWith(s2.toLowerCase());
    }

    /**
     * A shortcut method to use with filterEntities to retrieve a Member's nickname if present, else an empty string.
     */
    private static String memberGetNickname(Member member) {
        return member.getNickname().orElse("");
    }

    /**
     * Very generic filter method which can be applied to any class. Designed with Discord4J Entities in mind.
     *
     * @param <E> Any Class, although designed for Discord4J Entity Classes
     * @param <T> The comparison value Type
     * @param entities list of Discord4J entities to filter, although anything could be passed in
     * @param getValue the method used to get the comparison value of the entity
     * @param comparator the method to compare the entity value and comparison value with
     * @param comparison the value to compare against
     * @return a {@link List} of entities which only contains those that matched with the provided comparator
     */
    private static <E, T> List<E> filterEntities(List<E> entities, Function<E, T> getValue, Compare<T> comparator, T comparison) {
        return entities.stream()
            .filter(entity -> comparator.compare(getValue.apply(entity), comparison))
            .collect(Collectors.toList());
    }

    /**
     * Search through a list of users by by either their ID or name.
     *
     * First tries to match based on if the term is all numbers and first assumes the term is a Snowflake ID.
     * Since Snowflakes are very unique, and very unlikely to be an exact match for a username, they are checked for
     *  first. If there is a match between one user's name and another user's ID then that case cannot be reasonably
     *  avoided as there is no context for which is the right choice. However, we can assume that if a length of
     *  numbers is inserted it is very likely an ID.
     *
     * If no *single* user is found by ID, then attempt to search for names starting with the provided phrase, a check
     *  is done to see if the provided term is a full user name (name+discriminator) but only the name part is checked
     *  at first. If there are multiple results then another filter is applied for the discriminator if present.
     *
     * @param users A list of users or members to search through, normally sourced from a guild.
     * @param term the term to filter users by, can be a raw snowflake, a mention, a part of their name,
     *             or an exact match of its name with or without the discriminator attached.
     * @return a list with one user if a potential match is found, 0 or more than 1 users otherwise
     */
    public static <T extends User> List<T> searchUsersByTerm(List<T> users, String term) {
        List<T> results = new ArrayList<>();
        // Avoid returning the entire list of users when the term isn't present
        if (term.isEmpty()) return results;

        // Check if the term is a snowflake, note that users can set their name to be a bunch of numbers!
        Matcher matcher = snowflakeRegex.matcher(term);
        if (matcher.matches()) {
            // ignore snowflakes that do not belong to a user if passed by mention
            if (matcher.group(1).equals("@") || matcher.group(1).isEmpty()) {
                Snowflake id = Snowflake.of(matcher.group(2));
                results = filterEntities(users, User::getId, Snowflake::equals, id);
                if (results.size() == 1) {
                    return results;
                }
            }
        }

        // See if we should try and search by full username
        matcher = fullNameRegex.matcher(term);
        // If no match then just assume the term is a partial name
        String username = term;
        if (matcher.matches()) { username = matcher.group(1); }

        String finalUsername = username;
        results = filterEntities(users, User::getUsername, EntitySearch::stringStartsWithIgnoreCase, finalUsername);

        // Since we are searching for a single user, filter by ids now if possible
        // There has to be a better design to accomplish the logic here instead of chaining array iteration filters
        // But the amount of remaining users should be small (as long as a long enough term was used)
        if (results.size() > 1 && matcher.matches()) {
            String discriminator = matcher.group(2);
            results = filterEntities(results, User::getDiscriminator, String::equals, discriminator);
        }

        // Final attempt, if there are still multiple results then make sure there are no edge cases where exact
        //  matches are missed, would try to simply go after the first exact match with regex or similar but then
        //  the edge case where two people have the exact same name arises ...
        if (results.size() > 1) {
            List<T> exactMatches = filterEntities(results, User::getUsername, String::equalsIgnoreCase, finalUsername);
            if (exactMatches.size() > 0) {
                results = exactMatches;
            }
        }

        return results;
    }

    /**
     * Search through a list of users by by either their ID or name.
     * See searchUsersByTerm for additional documentation.
     *
     * First tries to search by user details alone, if a single result is found then return it.
     * If multiple (or zero) results are found then attempt a search based on the user's guild nickname.
     *
     * @param members A list of users to search through, normally sourced from a guild.
     * @param term the term to filter users by, can be a raw snowflake, a mention, a part of their name,
     *             or an exact match of its name with or without the discriminator attached
     * @return a list with one member if a potential match is found, 0 or more than 1 members otherwise
     */
    public static List<Member> searchMembersByTerm(List<Member> members, String term) {
        List<Member> results = new ArrayList<>(members);
        results = searchUsersByTerm(results, term);

        // Found a member based on user info, return
        if (results.size() == 1 || term.isEmpty()) {
            return results;
        }

        // Search guild nicknames, we don't attempt to filter by discriminators as it is likely redundant
        //  and improper formatting. I don't know where else something would show/accept nickname#discrimintator
        results = filterEntities(members, EntitySearch::memberGetNickname, EntitySearch::stringStartsWithIgnoreCase, term);

        // If there are still multiple results then make sure there are no edge cases where exact matches are missed,
        //  would try to simply go after the first exact match however members can have colliding nick names
        if (results.size() > 1) {
            List<Member> exactMatches = filterEntities(results, EntitySearch::memberGetNickname, String::equalsIgnoreCase, term);
            if (exactMatches.size() > 0) {
                results = exactMatches;
            }
        }

        return results;
    }

    /**
     * Search through a list of channels by their ID or name.
     * See searchUsersByTerm for additional documentation.
     *
     * First tries to match based on if the term is all numbers and first assumes the term is a Snowflake ID.
     *
     * If no *single* channel is found by ID, then attempt to search for names starting with the provided phrase,
     *  if there are multiple results then filter again looking for an exact match.
     *
     * @param channels A list of guild channels to search through, normally sourced from a guild directly
     * @param term the term to filter channels by, can be a raw snowflake, a mention,
     *             a part of its name, or an exact match of its name
     * @return a list with one channel if a potential match is found, 0 or more than 1 channels otherwise
     */
    public static List<GuildChannel> searchGuildChannelsByTerm(List<GuildChannel> channels, String term) {
        List<GuildChannel> results = new ArrayList<>();
        // Avoid returning the entire list of channels when the term isn't present
        if (term.isEmpty()) return results;

        // Check if the term is a snowflake, note that channels can have their name set to be a bunch of numbers!
        Matcher matcher = snowflakeRegex.matcher(term);
        if (matcher.matches()) {
            // ignore snowflakes that do not belong to a channel if passed by mention
            if (matcher.group(1).equals("#") || matcher.group(1).isEmpty()) {
                Snowflake id = Snowflake.of(matcher.group(2));
                results = filterEntities(channels, GuildChannel::getId, Snowflake::equals, id);
                if (results.size() == 1) {
                    return results;
                }
            }
        }

        // Try and search by channel name
        String channelName = term.toLowerCase();
        results = filterEntities(channels, GuildChannel::getName, EntitySearch::stringStartsWithIgnoreCase, channelName);

        // If there are still multiple results then make sure there are no edge cases where exact matches are missed,
        //  would try to simply go after the first exact match however channels can have colliding names
        if (results.size() > 1) {
            List<GuildChannel> exactMatches = filterEntities(results, GuildChannel::getName, String::equalsIgnoreCase, channelName);
            if (exactMatches.size() > 0) {
                results = exactMatches;
            }
        }

        return results;
    }

    /**
     * Search through a list of channels by their ID or name.
     * See searchUsersByTerm for additional documentation.
     *
     * First tries to match based on if the term is all numbers and first assumes the term is a Snowflake ID.
     *
     * If no *single* channel is found by ID, then attempt to search for names starting with the provided phrase,
     *  if there are multiple results then filter again looking for an exact match.
     *
     * @param roles A list of guild roles to search through, normally sourced from a guild directly
     * @param term the term to filter roles by, can be a raw snowflake, a mention,
     *             a part of its name, or an exact match of its name
     * @return a list with one channel if a potential match is found, 0 or more than 1 channels otherwise
     */
    public static List<Role> searchRolesByTerm(List<Role> roles, String term) {
        List<Role> results = new ArrayList<>();
        // Avoid returning the entire list of channels when the term isn't present
        if (term.isEmpty()) return results;

        // Check if the term is a snowflake, note that channels can have their name set to be a bunch of numbers!
        Matcher matcher = snowflakeRegex.matcher(term);
        if (matcher.matches()) {
            // ignore snowflakes that do not belong to a channel if passed by mention
            if (matcher.group(1).equals("@&") || matcher.group(1).isEmpty()) {
                Snowflake id = Snowflake.of(matcher.group(2));
                results = filterEntities(roles, Role::getId, Snowflake::equals, id);
                if (results.size() == 1) {
                    return results;
                }
            }
        }

        // Try and search by role name
        String roleName = term.toLowerCase();
        results = filterEntities(roles, Role::getName, EntitySearch::stringStartsWithIgnoreCase, roleName);

        // If there are still multiple results then make sure there are no edge cases where exact matches are missed,
        //  would try to simply go after the first exact match however roles can have colliding names
        if (results.size() > 1) {
            List<Role> exactMatches = filterEntities(results, Role::getName, String::equalsIgnoreCase, roleName);
            if (exactMatches.size() > 0) {
                results = exactMatches;
            }
        }

        return results;
    }
}
