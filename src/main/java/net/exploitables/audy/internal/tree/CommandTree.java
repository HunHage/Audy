/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.internal.tree;

import net.exploitables.audy.data.CommandConfig;
import net.exploitables.audy.internal.ArgsList;

import java.util.Optional;

/**
 * A very opinionated implementation of a Tree data structure.
 *
 * This tree is intended to be used for command mapping,
 *  a single construction with no alterations and a singular access method.
 */
public class CommandTree {
    // The key for the root node is the bot's prefix, however since the prefix varies between guilds
    // it is always presumed the prefix was spoken when accessing the tree
    private CommandTreeNode root;

    /**
     * Create an empty CommandTree with a default action
     * @param defaultValue the value for the root node
     */
    public CommandTree(CommandConfig defaultValue) {
        this.root = new CommandTreeNode(null, defaultValue, null);
    }

    /**
     * Create a new node at the given position with the specified value.
     * The key will be the final entry in the route.
     * Any missing nodes on the route will be created with the value being the same as the root node
     * @param newNodeValue value for the new node, the key is the last one provided on the route
     * @param route a "list" of keys representing the route to the new node,
     *              with the final entry being the new child key
     * @return the newly created child
     */
    public final CommandTreeNode addChildByRoute(CommandConfig newNodeValue, String... route) {
        // Assert we have a path
        assert route.length > 0;

        CommandTreeNode currentNode = this.root;
        int i;
        for (i = 0; i < route.length - 1; i++) {
            String currentKey = route[i];
            Optional<CommandTreeNode> nextNode = currentNode.getChildByKey(currentKey);
            if (nextNode.isPresent()) {
                currentNode = nextNode.get();
            } else {
                currentNode = currentNode.addChild(currentKey, root.getValue());
            }
        }

        // Assert we are not overriding an existing node
        assert !currentNode.getChildByKey(route[i]).isPresent();
        // Create the final intended node
        return currentNode.addChild(route[i], newNodeValue);
    }

    /**
     * Get the lowest node according to a given route, removing parts of the route successfully traveled.
     * Removes keys in the keyRoute as they are successfully found.
     * @param keyRoute a list of keys to search through the tree for a given node
     * @return the {@link CommandTreeNode} found, or the root node if not found
     */
    public CommandTreeNode getNodeByRoute(ArgsList<String> keyRoute) {
        return getNodeChildRecursive(keyRoute, this.root);
    }

    // Implementation for getNodeByRoute
    private CommandTreeNode getNodeChildRecursive(ArgsList<String> keyRoute, CommandTreeNode node) {
        Optional<CommandTreeNode> nextNode = node.getChildByKey(keyRoute.current());
        if (nextNode.isPresent()) {
            keyRoute.advance();
            return getNodeChildRecursive(keyRoute, nextNode.get());
        } else {
            return node;
        }
    }
}
