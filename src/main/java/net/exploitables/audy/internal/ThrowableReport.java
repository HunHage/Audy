/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.internal;

import discord4j.common.util.Snowflake;
import discord4j.core.object.entity.channel.MessageChannel;
import net.exploitables.audy.AudyClient;
import net.exploitables.audy.AudyMain;
import net.exploitables.audy.utilities.FileManager;
import net.exploitables.audy.utilities.TimeFormatter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.Map;

public class ThrowableReport {
    private static Logger logger = LoggerFactory.getLogger(ThrowableReport.class);

    private final Throwable primary;
    private final Throwable secondary;
    private final String message;

    private String reportTitle;

    public ThrowableReport(Throwable throwable) {
        this.primary = throwable;
        this.secondary = throwable.getCause();
        this.message = null;
        generateTitle();
    }

    public ThrowableReport(Throwable throwable, String message) {
        this.primary = throwable;
        this.secondary = throwable.getCause();
        this.message = message;
        generateTitle();
    }

    /**
     * Generate a title displaying the throwable class name and message
     *  If the throwable has a secondary cause then it's class name and message will be appended
     */
    private void generateTitle() {
        StringBuilder builder = new StringBuilder();
        builder.append(primary.getClass().getCanonicalName()).append(": ").append(primary.getMessage());

        if (secondary != null) {
            builder.append(", caused by ").append(secondary.getClass().getCanonicalName())
                    .append(": ").append(secondary.getLocalizedMessage());
        }

        if (message != null) {
            builder.append(", with the message: ").append(message);
        }

        this.reportTitle = builder.toString();
    }

    /**
     * Construct a string representation of a throwable's *entire* stack trace,
     *  including the stack trace of the throwable's secondary cause if it exists
     *
     * @return a String of the formatted stack trace(s)
     */
    private String generateTrace() {
        StringBuilder content = new StringBuilder();

        content.append(primary.getClass().getCanonicalName());
        for (StackTraceElement stackTraceElement : primary.getStackTrace()) {
            content.append(stackTraceElement.toString()).append("\n");
        }

        if (secondary != null) {
            content.append("\n\n").append(secondary.getClass().getCanonicalName());
            for (StackTraceElement stackTraceElement : secondary.getStackTrace()) {
                content.append(stackTraceElement.toString()).append("\n");
            }
        }

        return content.toString();
    }

    /**
     * Gathers additional custom information from a {@link DetailedThrowable} and constructs
     *  a String of that information calling {@link #buildAdditionalLog(DetailedThrowable)}
     *  on the primary and secondary throwable if they exist
     *
     * @return String containing additional log information
     */
    private String generateAdditionalLog() {
        String content = "";
        if (this.primary instanceof DetailedThrowable) {
            content += primary.getClass().getCanonicalName() + "\n";
            content += buildAdditionalLog((DetailedThrowable) this.primary);
        }
        if (this.secondary instanceof DetailedThrowable) {
            content += secondary.getClass().getCanonicalName() + "\n";
            content += buildAdditionalLog((DetailedThrowable) this.secondary);
        }

        return content;
    }

    private String buildAdditionalLog(DetailedThrowable detailedThrowable) {
        StringBuilder builder = new StringBuilder();
        for (Map.Entry<String, String> entry : detailedThrowable.getAdditionalLog().entrySet()) {
            builder.append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
        }

        return builder.toString();
    }

    /**
     * Receive and handle exceptions by logging to a file.
     *  {@link #logExceptionToFile()} Logs the exception name and reason to a file as well as stack trace.
     *  {@link #sendErrorMessage()}   Then sends a short message to the global discord channel as a report.
     *
     *  This method is generic only to be usable in any reactive chain
     *
     * @return an Empty Mono
     */
    public <T> Mono<T> reportException() {
        logger.error("An unhandled exception was thrown: " + reportTitle);
        logExceptionToFile();
        return sendErrorMessage();
    }

    /**
     * Receive and handle an internal exception that can't be as graciously handled as with
     *  {@link #reportException()}. This only prints the exception title and stack trace to the console.
     *
     *  This method is generic only to be usable in any reactive chain
     */
    public <T> Mono<T> reportInternalException() {
        logger.error("A vital exception has occurred: " + reportTitle);
        logger.error(generateTrace());
        return Mono.empty();
    }

    /**
     * Save a throwable's name, message, and stack trace to a file, including the throwable cause if present.
     */
    private void logExceptionToFile() {
        FileManager.saveLog(reportTitle + "\n\n" + generateAdditionalLog() + "\n\n" + generateTrace());
    }

    /**
     * Send a message to the global error channel specified in {@link net.exploitables.audy.AudyConfig}
     * If the channel id provided is 0 then no message is sent, effectively disabling this function
     *
     * This method is generic only to be usable in any reactive chain
     *
     * @return an Empty Mono
     */
    private <T> Mono<T> sendErrorMessage() {
        return Mono.just(AudyMain.getConfiguration().getReportChannelId())
            .filter(snowflake -> snowflake.equals(Snowflake.of(0)))
            .flatMap(snowflake -> AudyClient.getClient().getGateway().getChannelById(snowflake))
            .ofType(MessageChannel.class)
            .flatMap(c -> c.createMessage("`" + reportTitle + "` thrown at " + TimeFormatter.formatNowUTC()))
            .onErrorResume(t -> { new ThrowableReport(t).reportInternalException(); return Mono.empty(); })
            .then(Mono.empty());
    }
}
