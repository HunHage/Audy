/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.internal;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

/**
 * A basic {@link ArrayList} extension to enhance common access methods used by the bot.
 */
public class ArgsList<T> extends ArrayList<T> implements List<T> {
    // The bot will not always read the ArgsList in a purely iterative manner
    // Thus it is randomly accessed, and only progresses when progression is ensured
    private int position;

    public ArgsList(Collection<T> collection) {
        super(collection);
        this.position = 1; // Skip the prefix
    }

    /**
     * Parse and clean up content from a DiscordMessage.
     * - All spaces before/after the first/last words respectively are removed
     * - All tabs and newlines are converted to a space
     * - Multiple consecutive spaces (or tabs/newlines) are turned into one space
     *
     * @param content discord message content
     * @return an ArgsList instance created from the content
     */
    public static ArgsList<String> fromMessageContent(String content) {
        // Anywhere there is 1 or more whitespace replace it all with one space
        content = content.replaceAll("[\\s]+", " ").trim();
        return new ArgsList<>(Arrays.asList(content.split(" ")));
    }

    /**
     * @return get the entry at the instance position
     */
    public T current() {
        if (this.position >= this.size()) return null;
        return this.get(position);
    }

    /**
     * Advance the instance position by one
     */
    public void advance() {
        position++;
    }

    /**
     * Return the current instance position value and advance instance position by one
     * @return the entry at the current position
     */
    public T next() {
        this.advance();
        return this.current();
    }

    /**
     * @return the entry before the current position without modifying the position counter
     */
    public T peekPrevious() {
        return this.get(position - 1);
    }

    /**
     * @return the amount of terms remaining including the current position
     */
    public int remaining() {
        return this.size() - position;
    }
}
