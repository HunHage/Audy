/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.subscribers;

import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.object.entity.Guild;
import discord4j.core.object.entity.Member;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.User;
import discord4j.core.object.entity.channel.MessageChannel;
import discord4j.core.spec.EmbedCreateSpec;
import discord4j.rest.util.PermissionSet;
import net.exploitables.audy.AudyClient;
import net.exploitables.audy.commands.CommandResponse;
import net.exploitables.audy.commands.CommandState;
import net.exploitables.audy.commands.DefaultResponse;
import net.exploitables.audy.commands.TestCommand;
import net.exploitables.audy.commands.guild.info.InfoUser;
import net.exploitables.audy.data.DiscordPermission;
import net.exploitables.audy.data.Pair;
import net.exploitables.audy.data.bundles.GuildMessageEventBundle;
import net.exploitables.audy.internal.ArgsList;
import net.exploitables.audy.internal.DetailedThrowable;
import net.exploitables.audy.internal.ThrowableReport;
import net.exploitables.audy.internal.tree.CommandTree;
import net.exploitables.audy.internal.tree.CommandTreeNode;
import net.exploitables.audy.utilities.EnumList;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.EnumSet;
import java.util.function.Consumer;

public class CommandListener {
    private static final Logger logger = LoggerFactory.getLogger(CommandListener.class);
    private static CommandListener singleton = null;

    // Enum used when evaluating how to respond to potential commands
    enum PermissionState {
        NO_SEND,
        NO_PERMS,
        ALL_PERMS
    }

    private CommandTree commandTree;

    private CommandListener() {
        // Initialize the command tree with the default command response
        commandTree = new CommandTree(DefaultResponse.get().getCommandConfig());
        commandTree.addChildByRoute(InfoUser.get().getCommandConfig(), "info", "user");
        commandTree.addChildByRoute(TestCommand.get().getCommandConfig(), "test");
        commandTree.addChildByRoute(TestCommand.get().getCommandConfig(), "test", "route", "long");
    }

    public static CommandListener getSingleton() {
        if (singleton == null) singleton = new CommandListener();
        return singleton;
    }

    /**
     * Receive a new MessageCreateEvent from the gateway and handle it with the presumption it is a command.
     * @param event event representing a newly created message
     * @return the Message sent in reply to the command, empty if not a command, required data is missing, or the
     *  command responded in a custom way.
     */
    public Mono<Message> receiveMessageCreateEvent(MessageCreateEvent event) {
        // Get the Calling User and return empty if no User is present of the User is a bot
        if (!event.getMember().isPresent()) return Mono.empty();
        Member member = event.getMember().get();
        if (member.isBot()) return Mono.empty();
        // We need the channel for replying to the Calling User, return if not present
        MessageChannel channel = event.getMessage().getChannel().block();
        if (channel == null) return Mono.empty();
        // Get the Guild and GuildConfig, return empty if either aren't present
        Guild guild = event.getGuild().block();
        if (guild == null) return Mono.empty();
        // GuildConfig gConfig = ...
        // if (gConfig == null) return Mono.empty();

        // Check for prefix and attempt command execution if present
        // FUTURE: Guild Prefix
        if (startsWithPrefix(event.getMessage().getContent(), "a-")) {
            // Locate CommandConfig from CommandTree
            ArgsList<String> args = ArgsList.fromMessageContent(event.getMessage().getContent());
            CommandTreeNode node = commandTree.getNodeByRoute(args);

            // Check permissions, return if missing
            Pair<PermissionState, Consumer<EmbedCreateSpec>> permCheck = checkPerms(node, guild, member);
            // No message send permissions, return
            if (permCheck.getKey().equals(PermissionState.NO_SEND)) {
                return Mono.empty();
            // Missing permissions, send and return the supplied message
            } else if (permCheck.getKey().equals(PermissionState.NO_PERMS)) {
                return channel.createEmbed(permCheck.getValue());
            }

            GuildMessageEventBundle bundle = new GuildMessageEventBundle(event, member, args, node, guild);
            // We want to start with a Mono ASAP to take advantage of Reactor error handling
            Mono.just(bundle)
                    // Kinda weird, as we're calling a property of the bundle with an argument with itself
                    .flatMap(b -> b.getCommandNode().getValue().getCommand().executeCommand(b))
                    // Catch unhandled exceptions
                    .onErrorResume(throwable -> {
                        bundle.getResponse().setThrowable(throwable);
                        return Mono.empty();
                    })
                    .block();

            // Reply to the Calling User based on the CommandState
            CommandResponse response = bundle.getResponse();
            // An expected or handled error occurred, respond with the accompanying error message
            if (response.getState().notifyError()) {
                // Commands should always set their state and a message/embed
                if (response.getState() == CommandState.UNKNOWN) {
                    response.setThrowable(new DetailedThrowable("CommandStateUnknown").addEventLog(event));
                    new ThrowableReport(response.getThrowable()).reportException();
                }
                return bundle.getChannel().get().createMessage(response.asMessage());
            // Command ran successfully, respond with the contents of CommandState
            } else if (response.getState().shouldRespond() && bundle.getChannel().isPresent()) {
                return bundle.getChannel().get().createMessage(bundle.getResponse().asMessage());
            // Command ran successfully and replied to the Calling User in it's own way.
            } else {
                return Mono.empty();
            }
        }

        // Return empty if not a command
        return Mono.empty();
    }

    /**
     * Check if the Bot and Calling user have the required permissions to execute the command
     * @param node the CommandTree node for the command
     * @param guild the guild the command was called in
     * @param member the Calling User
     * @return a pair of the PermissionsState, and a MessageCreateSpec if permissions are missing when messages can be sent
     */
    private Pair<PermissionState, Consumer<EmbedCreateSpec>> checkPerms(CommandTreeNode node, Guild guild, Member member) {
        // Check command permissions for Calling User and Bot
        PermissionSet botPerms = guild
                .getMemberById(AudyClient.getClient().getSelfId())
                .flatMap(Member::getBasePermissions)
                .blockOptional()
                .orElse(PermissionSet.none());
        EnumSet<DiscordPermission> missingBotPerms = node.getValue().getMissingBotPermissions(botPerms);
        EnumSet<DiscordPermission> missingUserPerms = node.getValue().getMissingMemberPermissions(member.getBasePermissions().block());

        // Bot doesn't have permissions to send messages back to the same channel
        if (missingBotPerms.contains(DiscordPermission.SEND_MESSAGES)) return new Pair<>(PermissionState.NO_SEND, null);
        if (!missingBotPerms.isEmpty() || !missingUserPerms.isEmpty()) {
            Consumer<EmbedCreateSpec> embed = (spec) -> {
                spec.setTitle("Permissions Missing!");
                spec.setDescription("There are permissions missing for you to use the `" + String.join(" ", node.getRoute()) + "` command.");
                if (!missingBotPerms.isEmpty()) {
                    String selfUsername = AudyClient.getClient().getGateway().getSelf()
                        .map(User::getUsername)
                        .blockOptional()
                        .orElse("Audy");
                    spec.addField("I (" + selfUsername + ") need these permissions:",
                        EnumList.createEnumList(missingBotPerms).toString(),
                        true);
                }
                if (!missingUserPerms.isEmpty()) {
                    spec.addField("You (" + member.getDisplayName() + ") need these permissions:",
                        EnumList.createEnumList(missingUserPerms).toString(),
                        true);
                }
            };

            return new Pair<>(PermissionState.NO_PERMS, embed);
        } else {
            return new Pair<>(PermissionState.ALL_PERMS, null);
        }
    }

    /**
     * Check of the provided string starts with the bot prefix.
     * @param content content of the message to check for the prefix
     * @param prefix the guild prefix to check for
     * @return true if content starts with prefix ignoring case, false otherwise
     */
    private boolean startsWithPrefix(String content, String prefix) {
        // Prevent IndexOutOfBounds exception
        if (prefix.length() > content.length()) return false;
        return content.substring(0, prefix.length()).equalsIgnoreCase(prefix);
    }
}
