/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.subscribers;

import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.object.entity.Guild;
import discord4j.core.object.entity.Member;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.User;
import discord4j.core.object.entity.channel.MessageChannel;
import discord4j.core.spec.EmbedCreateSpec;
import net.exploitables.audy.AudyClient;
import net.exploitables.audy.AudyMain;
import net.exploitables.audy.commands.CommandResponse;
import net.exploitables.audy.commands.CommandState;
import net.exploitables.audy.commands.arguments.ArgumentParserResult;
import net.exploitables.audy.commands.guild.DefaultResponse;
import net.exploitables.audy.commands.guild.PingCommand;
import net.exploitables.audy.commands.guild.TestCommand;
import net.exploitables.audy.commands.guild.config.GuildPrefixCommand;
import net.exploitables.audy.commands.guild.help.HelpCommand;
import net.exploitables.audy.commands.guild.info.InfoChannelCommand;
import net.exploitables.audy.commands.guild.info.InfoGuildCommand;
import net.exploitables.audy.commands.guild.info.InfoRoleCommand;
import net.exploitables.audy.commands.guild.info.InfoUserCommand;
import net.exploitables.audy.commands.guild.remind.RemindDeleteAll;
import net.exploitables.audy.commands.guild.remind.RemindMeOnceCommand;
import net.exploitables.audy.data.CommandCategory;
import net.exploitables.audy.data.DiscordPermission;
import net.exploitables.audy.data.Pair;
import net.exploitables.audy.data.bundles.GuildMessageEventBundle;
import net.exploitables.audy.data.entity.GuildConfigFactory;
import net.exploitables.audy.internal.ArgsList;
import net.exploitables.audy.internal.DetailedThrowable;
import net.exploitables.audy.internal.ThrowableReport;
import net.exploitables.audy.internal.tree.CommandTree;
import net.exploitables.audy.internal.tree.CommandTreeNode;
import net.exploitables.audy.utilities.ListFormatter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.EnumSet;
import java.util.Map;
import java.util.function.Consumer;

public class CommandListener {
    private static final Logger logger = LoggerFactory.getLogger(CommandListener.class);
    private static CommandListener singleton = null;

    // Enum used when evaluating how to respond to potential commands
    enum PermissionState {
        NO_SEND,
        NO_PERMS,
        ALL_PERMS
    }

    private Map<Long, String> guildPrefixMap;
    private CommandTree commandTree;

    private CommandListener() {
        // Get all known guild prefixes from SQL, only storing id/prefix if a custom prefix is set
        guildPrefixMap = GuildConfigFactory.getAllGuildPrefixes();
        // Initialize the command tree with the default command response
        commandTree = new CommandTree(DefaultResponse.get().getCommandConfig());

        // ##### SQL Required for Functionality #####
        if (AudyMain.getConfiguration().isSqlEnabled()) {
            // Remind Commands
            commandTree.addTopLevelChild(DefaultResponse.get().getCommandConfig(),   "remind", CommandCategory.Hidden);
            commandTree.addChildByRoute(RemindMeOnceCommand.get().getCommandConfig(),"remind", "me", "once");
            commandTree.addChildByRoute(RemindDeleteAll.get().getCommandConfig(),    "remind", "delete");
            // Configuration Commands
            commandTree.addTopLevelChild(DefaultResponse.get().getCommandConfig(),   "config", CommandCategory.Configuration);
            commandTree.addChildByRoute(GuildPrefixCommand.get().getCommandConfig(), "config", "guild", "prefix");
        }
        // ##### SQL Optional for Functionality #####
        // Help
        commandTree.addTopLevelChild(HelpCommand.get().getCommandConfig(),       "help", CommandCategory.Help);
        // Info Commands
        commandTree.addTopLevelChild(DefaultResponse.get().getCommandConfig(),   "info", CommandCategory.Information);
        commandTree.addChildByRoute(InfoUserCommand.get().getCommandConfig(),    "info", "user");
        commandTree.addChildByRoute(InfoChannelCommand.get().getCommandConfig(), "info", "channel");
        commandTree.addChildByRoute(InfoRoleCommand.get().getCommandConfig(),    "info", "role");
        commandTree.addChildByRoute(InfoGuildCommand.get().getCommandConfig(),   "info", "guild");
        // Miscelaneous
        commandTree.addTopLevelChild(PingCommand.get().getCommandConfig(),       "ping", CommandCategory.Miscellaneous);

        // Test Command
        commandTree.addChildByRoute(TestCommand.get().getCommandConfig(),        "test");
    }

    public static CommandListener get() {
        if (singleton == null) singleton = new CommandListener();
        return singleton;
    }

    /**
     * Receive a new MessageCreateEvent from the gateway and handle it with the presumption it is a command.
     * @param event event representing a newly created message
     * @return the Message sent in reply to the command, empty if not a command, required data is missing, or the
     *  command responded in a custom way.
     */
    public Mono<Message> receiveMessageCreateEvent(MessageCreateEvent event) {
        // Get the Calling User and return empty if no User is present of the User is a bot
        if (!event.getMember().isPresent()) return Mono.empty();
        Member member = event.getMember().get();
        if (member.isBot()) return Mono.empty();
        // We need the channel for replying to the Calling User, return if not present
        MessageChannel channel = event.getMessage().getChannel().block();
        if (channel == null) return Mono.empty();
        // Get the Guild and GuildConfig, return empty if either aren't present
        Guild guild = event.getGuild().block();
        if (guild == null) return Mono.empty();

        // Check for prefix and attempt command execution if present
        String guildPrefix = getGuildPrefix(guild.getId().asLong());
        if (startsWithPrefix(event.getMessage().getContent(), guildPrefix)) {
            // Locate CommandConfig from CommandTree
            ArgsList args = ArgsList.fromMessageContent(event.getMessage().getContent(), guildPrefix);
            // Get the command to be called, leaving the current index of ArgsList at the first term after the command
            CommandTreeNode node = commandTree.getNodeByRoute(args);

            // Check permissions, return if missing
            Pair<PermissionState, Consumer<EmbedCreateSpec>> permCheck = checkPerms(node, guild, member);
            // No message send permissions, return
            if (permCheck.getKey().equals(PermissionState.NO_SEND)) {
                return Mono.empty();
            // Missing permissions, send and return the supplied message
            } else if (permCheck.getKey().equals(PermissionState.NO_PERMS)) {
                return channel.createEmbed(permCheck.getValue());
            }

            // Parse the args if needed
            ArgumentParserResult parsedArgs = Mono.justOrEmpty(node.getValue().getArgumentParser())
                    .flatMap(parser -> parser.parseArgs(args))
                    .onErrorResume(throwable -> new ThrowableReport(throwable).reportException())
                    .block();
            if (parsedArgs != null) {
                if (parsedArgs.hasError()) {
                    return channel.createMessage("Argument parsing failed with the following message: `" +
                        parsedArgs.getError() + "`");
                }
            } else {
                return channel.createMessage("Unable to parse arguments for command `" + node.getKey() + "`! While " +
                    "this is unexpected behavior please double check you typed everything correctly. If this issue " +
                    "persists please wait until a patch is applied.");
            }

            GuildMessageEventBundle bundle = new GuildMessageEventBundle(event, guild, member, args, node, parsedArgs);
            // We want to start with a Mono ASAP to take advantage of Reactor error handling
            Mono.just(bundle)
                    // Kinda weird, as we're calling a property of the bundle with an argument with itself
                    .flatMap(b -> b.getCommandNode().getValue().getCommand().executeCommand(b))
                    // Catch unhandled exceptions
                    .onErrorResume(throwable -> {
                        bundle.getResponse().setThrowable(throwable);
                        return Mono.empty();
                    })
                    .block();

            // Reply to the Calling User based on the CommandState
            CommandResponse response = bundle.getResponse();
            // An expected or handled error occurred, respond with the accompanying error message
            if (response.getState().notifyError()) {
                // Commands should always set their state and a message/embed
                if (response.getState() == CommandState.UNKNOWN) {
                    response.setThrowable(new DetailedThrowable("CommandStateUnknown").addEventLog(event));
                    new ThrowableReport(response.getThrowable()).reportException();
                }
                return bundle.getChannel().get().createMessage(response.asMessage());
            // Command ran successfully, respond with the contents of CommandState
            } else if (response.getState().shouldRespond() && bundle.getChannel().isPresent()) {
                return bundle.getChannel().get().createMessage(bundle.getResponse().asMessage());
            // Command ran successfully and replied to the Calling User in it's own way.
            } else {
                return Mono.empty();
            }
        }

        // Return empty if not a command
        return Mono.empty();
    }

    /**
     * Check if the Bot and Calling user have the required permissions to execute the command
     * @param node the CommandTree node for the command
     * @param guild the guild the command was called in
     * @param member the Calling User
     * @return a pair of the PermissionsState, and a MessageCreateSpec if permissions are missing when messages can be sent
     */
    private Pair<PermissionState, Consumer<EmbedCreateSpec>> checkPerms(CommandTreeNode node, Guild guild, Member member) {
        // Check command permissions for Calling User and Bot
        EnumSet<DiscordPermission> missingBotPerms = node.getValue().getMissingBotPermissions(guild);
        EnumSet<DiscordPermission> missingUserPerms = node.getValue().getMissingMemberPermissions(member.getBasePermissions().block());

        // Bot doesn't have permissions to send messages back to the same channel
        if (missingBotPerms.contains(DiscordPermission.SEND_MESSAGES)) return new Pair<>(PermissionState.NO_SEND, null);
        if (!missingBotPerms.isEmpty() || !missingUserPerms.isEmpty()) {
            Consumer<EmbedCreateSpec> embed = (spec) -> {
                spec.setTitle("Permissions Missing!");
                spec.setDescription("There are permissions missing for you to use the `" + String.join(" ", node.getRoute()) + "` command.");
                if (!missingBotPerms.isEmpty()) {
                    String selfUsername = AudyClient.getClient().getGateway().getSelf()
                        .map(User::getUsername)
                        .blockOptional()
                        .orElse("Audy");
                    spec.addField("I (" + selfUsername + ") need these permissions:",
                        "```" + ListFormatter.collectionToString(missingBotPerms, DiscordPermission::getFormattedName, 99, "none", "\n") + "```",
                        true);
                }
                if (!missingUserPerms.isEmpty()) {
                    spec.addField("You (" + member.getDisplayName() + ") need these permissions:",
                        "```" + ListFormatter.collectionToString(missingBotPerms, DiscordPermission::getFormattedName, 99, "none", "\n") + "```",
                        true);
                }
            };

            return new Pair<>(PermissionState.NO_PERMS, embed);
        } else {
            return new Pair<>(PermissionState.ALL_PERMS, null);
        }
    }

    /**
     * Check of the provided string starts with the bot prefix.
     * @param content content of the message to check for the prefix
     * @param prefix the guild prefix to check for
     * @return true if content starts with prefix ignoring case, false otherwise
     */
    private boolean startsWithPrefix(String content, String prefix) {
        // Prevent IndexOutOfBounds exception
        if (prefix.length() > content.length()) return false;
        return content.substring(0, prefix.length()).equalsIgnoreCase(prefix);
    }

    /**
     * Update a guild prefix immediately. Called when a command is used to change the guild prefix.
     * If prefix is null then the guild went back to the default prefix and the entry in the map will be removed.
     * @param guildId the id of the guild
     * @param prefix the new prefix to listen for in the guild
     */
    public void updateGuildPrefix(Long guildId, String prefix) {
        if (prefix != null) {
            guildPrefixMap.put(guildId, prefix);
        } else {
            guildPrefixMap.remove(guildId);
        }
    }

    /**
     * Get the prefix a guild is set to, returns a custom prefix or the default.
     * @param guildId guild id to get the prefix of
     */
    public String getGuildPrefix(Long guildId) {
        return guildPrefixMap.getOrDefault(guildId, AudyMain.getConfiguration().getDefaultPrefix());
    }

    public CommandTreeNode getCommandTreeNode(ArgsList argsList) {
        return commandTree.getNodeByRoute(argsList);
    }
}
