/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.commands;

import discord4j.common.util.Snowflake;
import net.exploitables.audy.data.CommandConfig;
import net.exploitables.audy.data.CommandConfigBuilder;
import net.exploitables.audy.data.bundles.MessageEventBundle;
import reactor.core.publisher.Mono;

/**
 * An example testing command to verify exception catching
 */
public class TestCommand {
    private static TestCommand singleton;

    // Command Configuration and reference to the command method.
    private CommandConfig commandConfig;

    /**
     * Create a new "TestCommand" command and configure it.
     */
    private TestCommand() {
        this.commandConfig = new CommandConfigBuilder(this::defaultCommand, TestCommand.class).build();
    }

    public static TestCommand get() {
        if (singleton == null) singleton = new TestCommand();
        return singleton;
    }

    /**
     * Command to test data access and various exception handling methods
     * @return an empty Mono when execution is complete
     */
    public <B extends MessageEventBundle> Mono<Void> defaultCommand(B bundle) {
        // We don't use the tree for this command to simplify testing
        if (bundle.getArgs().remaining() > 0) {
            switch (bundle.getArgs().current()) {
                case "exception-runtime":
                    throw new RuntimeException("Synthetic RuntimeException for 'test' command.");
                case "exception-double":
                    throw new RuntimeException("Synthetic RuntimeException with secondary cause for 'test' command.",
                            new RuntimeException("Synthetic RuntimeException as secondary cause."));
                case "exception-snowflake":
                    Snowflake.of("haha this isn't a snowflake and will throw a NumberFormatException");
                case "mono-exception":
                    Mono.error(new Exception("An uncaught and unhandled 'java.lang.Exception' placed in a Mono.error()"));
                    break;
                case "mono-throwable":
                    Mono.error(new Throwable("An uncaught and unhandled 'java.lang.Throwable' placed in a Mono.error()"));
                    break;
                case "mono-exception-return":
                    return Mono.error(new Exception("An uncaught and unhandled 'java.lang.Exception' returned with Mono.error()"));
                case "mono-throwable-return":
                    return Mono.error(new Throwable("An uncaught and unhandled 'java.lang.Throwable' returned with Mono.error()"));
            }
        } else {
            bundle.getResponse().setContent(String.join(" ", bundle.getCommandNode().getRoute()));
            bundle.getResponse().setState(CommandState.SUCCESS);
        }

        return Mono.empty();
    }

    public CommandConfig getCommandConfig() {
        return this.commandConfig;
    }
}
