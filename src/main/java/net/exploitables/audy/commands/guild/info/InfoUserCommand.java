/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.commands.guild.info;

import discord4j.common.util.Snowflake;
import discord4j.core.object.entity.Member;
import discord4j.core.object.entity.User;
import discord4j.core.spec.EmbedCreateSpec;
import discord4j.core.spec.MessageCreateSpec;
import discord4j.rest.http.client.ClientException;
import net.exploitables.audy.AudyClient;
import net.exploitables.audy.commands.CommandState;
import net.exploitables.audy.commands.DefaultResponse;
import net.exploitables.audy.data.CommandConfig;
import net.exploitables.audy.data.CommandConfigBuilder;
import net.exploitables.audy.data.bundles.GuildMessageEventBundle;
import net.exploitables.audy.utilities.CodeBlock;
import net.exploitables.audy.utilities.EntitySearch;
import net.exploitables.audy.utilities.TimeFormatter;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.function.Consumer;
import java.util.regex.Matcher;

/**
 * A command to show a small card of information pertaining to a user. The information shown is not private/sensitive.
 */
public class InfoUserCommand {
    private static InfoUserCommand singleton;
    private CommandConfig commandConfig;

    private InfoUserCommand() {
        this.commandConfig = new CommandConfigBuilder(this::execute, DefaultResponse.class).build();
    }

    public static InfoUserCommand get() {
        if (singleton == null) singleton = new InfoUserCommand();
        return singleton;
    }

    public CommandConfig getCommandConfig() {
        return this.commandConfig;
    }

    /**
     * Search for users within the guild by the term provided. If no user is found and the term is believed to be a
     *  Snowflake ID for a user then try and fetch the user and display information about them instead.
     *
     * Information displayed is all public and/or non-sensitive information. Although some of it *is* user data.
     * User ID                  Public Discord information              Discord Data
     * User Name                Viewable by anyone                      User Data
     * User Discriminator       Viewable by anyone                      Discord Data (at least it looks like it)
     * User Avatar              Viewable by anyone                      User Data
     * Account Creation Date    Part of the ID, so Public Discord Info  Discord Data
     * Account Join Date        Only obtainable by bot API              Discord Data (at least it looks like it)
     *
     * There is no way to obtain information about this user with this command without also having some level of access
     *  to the specified user already. Either knowing their ID or Name+Discriminator allows for most of this data to be
     *  obtained without the aid of this command. The one exception is that the Join Date is only available through the
     *  API but only works if Audy and the User share a server where the command is called.
     *
     * @param bundle bundle created from a command issued within a guild
     * @return an empty mono when execution is complete
     */
    public Mono<Void> execute(GuildMessageEventBundle bundle) {
        String term = bundle.getArgs().combineRemaining();
        List<Member> members = EntitySearch.searchMembersByTerm(bundle.getGuild().getMembers().collectList().block(), term);
        Consumer<MessageCreateSpec> message = spec -> {};

        // Found our match, generate embed and return
        if (members.size() == 1) {
            Member member = members.get(0);
            bundle.getResponse().updateEmbed(initializeEmbed(member));
            bundle.getResponse().updateEmbed(completeEmbedForMember(member));
            bundle.getResponse().setState(CommandState.SUCCESS);
            return Mono.empty();
        }

        // Check and see if the term given is a snowflake, may be a user outside the guild
        Matcher isSnowflake = EntitySearch.matchSnowflake(term);
        // FUTURE: Bucket Rate Limit
        if (isSnowflake.matches()) {
            Snowflake snowflake = Snowflake.of(isSnowflake.group(2));
            try {
                // Throws a ClientException with a 404 if the ID doesn't belong to a User or doesn't exist
                User user = AudyClient.getClient().getGateway().getUserById(snowflake).block();
                bundle.getResponse().updateEmbed(initializeEmbed(user));
                bundle.getResponse().updateEmbed(completeEmbedForUser(user));
                bundle.getResponse().setState(CommandState.SUCCESS);
            } catch (ClientException ce) {
                if (ce.getStatus().code() == 404) {
                    bundle.getResponse().setContentTitle("No user exists with that ID");
                    bundle.getResponse().setState(CommandState.FAILED);
                } else {
                    bundle.getResponse().setThrowable(ce);
                    bundle.getResponse().setState(CommandState.ERROR);
                }
            }
            return Mono.empty();
        }

        // 0 or 2+ members found, the term wasn't an ID, or no user existed by that ID if it was
        CodeBlock manip = new CodeBlock().setCodeType("ini");
        manip.append("[ ").append(term).append(" ] : ").append(members.toString());
        bundle.getResponse().setContentTitle("Only one user can be specified for this command, I found '"
                + members.size() + "'");
        bundle.getResponse().setContentDescription(manip.toString());
        bundle.getResponse().setState(CommandState.FAILED);

        return Mono.empty();
    }

    /**
     * Initialize an embed for a user, this is called before updating the embed for a member or user
     * @param user the user to initialize the embed for
     * @return a partially built embed for the user
     */
    private Consumer<EmbedCreateSpec> initializeEmbed(User user) {
        return (spec) -> {
            // Set the thumbnail
            spec.setThumbnail(user.getAvatarUrl());

            // Set the title to their full username + discriminator and show their ID
            spec.setTitle(user.getUsername() + "#" + user.getDiscriminator() + "  `ID:" + user.getId().asString() + "`");

            // Silent mention of the user
            spec.addField("Silent Mention",
                user.getMention(),
                true);
        };
    }

    /**
     * Complete an embed created by initializeEmbed() for a user that **isn't** present in the server.
     * @param user the user to complete the embed for
     * @return a fully built embed for the user
     */
    private Consumer<EmbedCreateSpec> completeEmbedForUser(User user) {
        return (spec) -> {
            // Add info on account creation date
            CodeBlock body = new CodeBlock();
            body.append("Created: ").append(TimeFormatter.formatUTC(user.getId())).newLine()
                .append("         " + TimeFormatter.formatAge(user.getId().getTimestamp()));

            spec.setDescription(body.toString());
        };
    }

    /**
     * Complete an embed created by initializeEmbed() for a user that **is** present in the server.
     * @param member the user to complete the embed for
     * @return a fully built embed for the user
     */
    private Consumer<EmbedCreateSpec> completeEmbedForMember(Member member) {
        return (spec) -> {
            // Add info on account creation date and guild join date
            CodeBlock body = new CodeBlock();
            body.append("Created: ").append(TimeFormatter.formatUTC(member.getId())).newLine()
                .append("         " + TimeFormatter.formatAge(member.getId().getTimestamp())).newLine()
                .append(" Joined: ").append(TimeFormatter.formatUTC(member.getJoinTime())).newLine()
                .append("         ").append(TimeFormatter.formatAge(member.getJoinTime()));

            spec.setDescription(body.toString());

            // Optional nickname field
            if (member.getNickname().isPresent()) {
                spec.addField("Nickname",
                        member.getNickname().get(),
                        true);
            }
        };
    }
}
