/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.commands.guild.info;

import discord4j.common.util.Snowflake;
import discord4j.core.object.entity.Member;
import discord4j.core.object.entity.User;
import discord4j.core.spec.EmbedCreateSpec;
import discord4j.rest.http.client.ClientException;
import net.exploitables.audy.AudyClient;
import net.exploitables.audy.commands.CommandState;
import net.exploitables.audy.commands.MessageBundle;
import net.exploitables.audy.data.CommandConfig;
import net.exploitables.audy.data.CommandConfigBuilder;
import net.exploitables.audy.utilities.EntitySearch;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.function.Consumer;
import java.util.regex.Matcher;

/**
 * A command to show a small card of information pertaining to a user. The information shown is not private/sensitive.
 */
public class InfoUserCommand extends InfoSuperCommand {
    private static InfoUserCommand singleton;
    private CommandConfig commandConfig;

    private InfoUserCommand() {
        this.commandConfig = new CommandConfigBuilder(this::execute, this.getClass())
            .addHelp("Show User Info: `%pinfo user <user>`",
                "Display information about the specified user within this guild (also known as a member). " +
                    "The user can be specified by the following:\n" +
                    "- Exact Username\n" +
                    "- User Snowflake ID\n" +
                    "- Unique Start of Username\n" +
                    "- Exact Username and Discriminator")
            .addHelp("Specifying Exact Username and Discriminator",
                "This would be the username and discriminator as it appears on their profile. ex: `user name#1234`")
            .addHelp("Specifying User Snowflake ID",
                "When specifying a Snowflake ID and the user is not in this guild, the user will be queried from " +
                    "Discord.")
            .build();
    }

    public static InfoUserCommand get() {
        if (singleton == null) singleton = new InfoUserCommand();
        return singleton;
    }

    public CommandConfig getCommandConfig() {
        return this.commandConfig;
    }

    /**
     * Search for users within the guild by the term provided. If no user is found and the term is believed to be a
     *  Snowflake ID for a user then try and fetch the user and display information about them instead.
     *
     * Information displayed is all public and/or non-sensitive information. Although some of it *is* user data.
     * User ID                  Public Discord information              Discord Data
     * User Name                Viewable by anyone                      User Data
     * User Discriminator       Viewable by anyone                      Discord Data (at least it looks like it)
     * User Avatar              Viewable by anyone                      User Data
     * Account Creation Date    Part of the ID, so Public Discord Info  Discord Data
     * Account Join Date        Only obtainable by bot API              Discord Data (at least it looks like it)
     *
     * There is no way to obtain information about this user with this command without also having some level of access
     *  to the specified user already. Either knowing their ID or Name+Discriminator allows for most of this data to be
     *  obtained without the aid of this command. The one exception is that the Join Date is only available through the
     *  API but only works if Audy and the User share a server where the command is called.
     *
     * @param bundle bundle created from a command issued within a guild
     * @return an empty mono when execution is complete
     */
    public Mono<Void> execute(MessageBundle bundle) {
        String term = bundle.getArgs().combineRemaining();
        //noinspection OptionalGetWithoutIsPresent
        List<Member> members = EntitySearch.searchMembersByTerm(bundle.getGuild().get().getMembers().collectList().block(), term);

        // Found our match, generate embed and return
        if (members.size() == 1) {
            Member member = members.get(0);
            bundle.getResponse().updateEmbed(initializeEmbed(member));
            bundle.getResponse().updateEmbed(completeEmbedForMember(member));
            bundle.getResponse().setState(CommandState.SUCCESS);
            return Mono.empty();
        }

        // Check and see if the term given is a snowflake, may be a user outside the guild
        Matcher isSnowflake = EntitySearch.matchSnowflake(term);
        // FUTURE: Bucket Rate Limit
        if (isSnowflake.matches()) {
            Snowflake snowflake = Snowflake.of(isSnowflake.group(2));
            try {
                // Throws a ClientException with a 404 if the ID doesn't belong to a User or doesn't exist
                User user = AudyClient.getClient().getGateway().getUserById(snowflake).block();
                bundle.getResponse().updateEmbed(initializeEmbed(user));
                bundle.getResponse().updateEmbed(completeEmbedForUser(user));
                bundle.getResponse().setState(CommandState.SUCCESS);
            } catch (ClientException ce) {
                if (ce.getStatus().code() == 404) {
                    bundle.getResponse().setContentTitle("No user exists with that ID");
                    bundle.getResponse().setState(CommandState.FAILED_EXPECTED);
                } else {
                    bundle.getResponse().setThrowable(ce);
                    bundle.getResponse().setState(CommandState.ERROR);
                }
            }
            return Mono.empty();
        }

        // 0 or 2+ users found by name
        super.generateBadResultsMessage(bundle, term, "user", members, User::getUsername);
        return Mono.empty();
    }

    /**
     * Initialize an embed for a user, this is called before updating the embed for a member or user
     * @param user the user to initialize the embed for
     * @return a partially built embed for the user
     */
    private Consumer<EmbedCreateSpec> initializeEmbed(User user) {
        return (spec) -> {
            // Set the thumbnail
            spec.setThumbnail(user.getAvatarUrl());

            // Set the title to their full username + discriminator and show their ID
            spec.setTitle(user.getUsername() + "#" + user.getDiscriminator() + "  `ID:" + user.getId().asString() + "`");

            // Silent mention of the user
            spec.addField("Silent Mention",
                user.getMention(),
                true);
        };
    }

    /**
     * Complete an embed created by initializeEmbed() for a user that **isn't** present in the server.
     * @param user the user to complete the embed for
     * @return a fully built embed for the user
     */
    private Consumer<EmbedCreateSpec> completeEmbedForUser(User user) {
        return (spec) -> {
            // Add info on account creation date
            spec.setDescription(super.generateAgeDescription(user.getId()));
        };
    }

    /**
     * Complete an embed created by initializeEmbed() for a user that **is** present in the server.
     * @param member the user to complete the embed for
     * @return a fully built embed for the user
     */
    private Consumer<EmbedCreateSpec> completeEmbedForMember(Member member) {
        return (spec) -> {
            spec.setDescription(super.generateMemberCreateAndJoinDescription(member));

            // Optional nickname field
            if (member.getNickname().isPresent()) {
                spec.addField("Nickname",
                        member.getNickname().get(),
                        true);
            }
        };
    }
}
