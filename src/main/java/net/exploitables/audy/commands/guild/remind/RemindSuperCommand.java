/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.commands.guild.remind;

import net.exploitables.audy.AudyScheduler;
import net.exploitables.audy.data.bundles.GuildMessageEventBundle;
import net.exploitables.audy.scheduler.ReminderJob;
import org.quartz.*;

import java.sql.Date;
import java.time.Instant;

public class RemindSuperCommand {
    /**
     * Schedule a new reminder for the provided user and channel.
     * @param jobDataMap        A pre-configured {@link JobDataMap} with the following information added:
     *                          userId, channelId, guildId (if channel is in a guild), message (if set), sourceLink
     * @param name              The name of the job.
     * @param group             The group of the job.
     * @param triggerTime       The time this job should start.
     * @throws SchedulerException
     */
    void scheduleReminderOnce(JobDataMap jobDataMap,
                              String name,
                              String group,
                              Instant triggerTime) throws SchedulerException {

        // Quartz seems to have NO way of telling if a job missed it's fire time
        jobDataMap.put("nextFireTime", triggerTime.toEpochMilli());

        JobDetail jobDetail = JobBuilder
            .newJob(ReminderJob.class)
            .withIdentity(name, group)
            .usingJobData(jobDataMap)
            .build();
        Trigger trigger = TriggerBuilder
            .newTrigger()
            .withIdentity(name, group)
            .startAt(Date.from(triggerTime))
            // When missing the scheduled firing time fire ASAP
            .withSchedule(SimpleScheduleBuilder.simpleSchedule().withMisfireHandlingInstructionFireNow())
            .build();

        AudyScheduler.getSqlRemindScheduler().scheduleJob(jobDetail, trigger);
    }

    /**
     * Parse the given string for an amount of time, and convert it to milliseconds.
     * Accepted formats are a repeating pattern of: 1+ numbers followed by a single character specifying the amount
     *  of time. Example: 1w1d1h1m
     * Accepted time values are *w*eeks, *d*ays, *h*ours, and *m*inutes.
     *
     * @param timeTerm an expression to parse a duration of time from such as 1w2d3m4s
     * @return the time specified in the provided term as a unit of minutes, -1 when a parsing error occurs.
     */
    long parseTimeIntoMinutes(String timeTerm) {
        long total = 0;
        int mult = 0;
        StringBuilder tempNumber = new StringBuilder();
        for (char c : timeTerm.toCharArray()) {
            if (Character.isAlphabetic(c)) {
                switch (c) {
                    case 'm': mult =     1; break;
                    case 'h': mult =    60; break;
                    case 'd': mult =  1440; break;
                    case 'w': mult = 10080; break;
                    default:  return -1; // Parsing error
                }
                if (tempNumber.length() > 0) {
                    total += mult * Integer.parseInt(tempNumber.toString());
                    tempNumber = new StringBuilder();
                } else {
                    return -1;
                }
            } else if (Character.isDigit(c)) {
                tempNumber.insert(0, c);
            } else {
                return -1; // Parsing error
            }
        }

        return total;
    }

    String createGroupForUser(GuildMessageEventBundle bundle) {
        return "User-" + bundle.getAuthor().getId().asString();
    }
}
