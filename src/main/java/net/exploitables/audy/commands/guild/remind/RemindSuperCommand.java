/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.commands.guild.remind;

import net.exploitables.audy.AudyScheduler;
import net.exploitables.audy.commands.CommandState;
import net.exploitables.audy.data.bundles.MessageEventBundle;
import net.exploitables.audy.scheduler.ReminderJob;
import org.joda.time.DateTime;
import org.quartz.*;
import org.quartz.impl.matchers.GroupMatcher;

import java.util.Set;

public class RemindSuperCommand {
    /**
     * Schedule a new reminder for the provided user and channel.
     * @param jobDataMap        A pre-configured {@link JobDataMap} with the following information added:
     *                          userId, channelId, guildId (if channel is in a guild), message (if set), sourceLink
     * @param name              The name of the job.
     * @param group             The group of the job.
     * @param triggerTime       The time this job should start.
     * @throws SchedulerException
     */
    void scheduleReminderOnce(JobDataMap jobDataMap,
                              String name,
                              String group,
                              DateTime triggerTime) throws SchedulerException {

        // Quartz seems to have NO way of telling if a job missed it's fire time
        jobDataMap.put("nextFireTime", triggerTime.getMillis());

        JobDetail jobDetail = JobBuilder
            .newJob(ReminderJob.class)
            .withIdentity(name, group)
            .usingJobData(jobDataMap)
            .build();
        Trigger trigger = TriggerBuilder
            .newTrigger()
            .withIdentity(name, group)
            .startAt(triggerTime.toDate())
            // When missing the scheduled firing time fire ASAP
            .withSchedule(SimpleScheduleBuilder.simpleSchedule().withMisfireHandlingInstructionFireNow())
            .build();

        AudyScheduler.getSqlRemindScheduler().scheduleJob(jobDetail, trigger);
    }

    boolean isUnderReminderLimit(MessageEventBundle bundle) throws SchedulerException {
        // Check that the user isn't at the semi-arbitrary limit of 10 reminders
        String group = createGroupForUser(bundle);
        Set<JobKey> jobKeys = AudyScheduler.getSqlRemindScheduler().getJobKeys(GroupMatcher.groupContains(group));
        if (jobKeys.size() >= 10) {
            bundle.getResponse().setContentTitle("You have 10 reminders in progress, please delete one " +
                "or wait for another one to finish.")
                .setState(CommandState.FAILED_EXPECTED);
            return false;
        }
        return true;
    }

    String createGroupForUser(MessageEventBundle bundle) {
        return "User-" + bundle.getAuthor().getId().asString();
    }

    /**
     * Combine two {@link DateTime} instances into one instance, one of the two must be non-null
     * @param date first {@link DateTime} instance, defaults to today if null
     * @param time second {@link DateTime} instance, nullable
     * @return the date instance with the hours/minutes of the time instance added to it, or the non-null instance
     */
    DateTime combineDateTimes(DateTime date, DateTime time) {
        if (date == null) {
            DateTime now = DateTime.now();
            time = time.withYear(now.getYear());
            time = time.withDayOfYear(now.getDayOfYear());
            return time;
        } else if (time == null) {
            return date;
        } else {
            date = date.withHourOfDay(time.getHourOfDay());
            date = date.withMinuteOfHour(time.getMinuteOfHour());
            return date;
        }
    }
}
