/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.commands.shared;

import net.exploitables.audy.AudyClient;
import net.exploitables.audy.AudyMain;
import net.exploitables.audy.commands.CommandState;
import net.exploitables.audy.commands.DirectCommandListener;
import net.exploitables.audy.commands.GuildCommandListener;
import net.exploitables.audy.commands.MessageBundle;
import net.exploitables.audy.commands.arguments.HelpArguments;
import net.exploitables.audy.data.CommandCategory;
import net.exploitables.audy.data.CommandConfig;
import net.exploitables.audy.data.CommandConfigBuilder;
import net.exploitables.audy.data.Pair;
import net.exploitables.audy.internal.ArgsList;
import net.exploitables.audy.internal.EnumFormattedName;
import net.exploitables.audy.internal.tree.CommandTreeNode;
import net.exploitables.audy.utilities.CodeBlock;
import net.exploitables.audy.utilities.ListFormatter;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * A command to show a small card of information pertaining to a channel.
 */
public class HelpCommand {
    private static HelpCommand singleton;
    private CommandConfig commandConfig;

    private HelpCommand() {
        this.commandConfig = new CommandConfigBuilder(this::execute, this.getClass())
                .setArgumentParser(HelpArguments.getInstance())
                .build();
    }

    public static HelpCommand get() {
        if (singleton == null) singleton = new HelpCommand();
        return singleton;
    }

    public CommandConfig getCommandConfig() {
        return this.commandConfig;
    }

    /**
     * Provide general help for the given command based on the contents of it's CommandConfig.
     * This can be called from a guild or a private channel
     *
     * @param bundle bundle created from a command issued within a guild
     * @return an empty mono when execution is complete
     */
    public Mono<Void> execute(MessageBundle bundle) {
        // We can just search for a node again after the ArgsList was parsed to find this help command.
        CommandTreeNode node = getNodeForListener(bundle.getGuild().isPresent(), bundle.getArgs());
        List<String> route = node.getRoute();

        // No command was found
        if (node.getValue().getCommandClass().isAssignableFrom(DefaultResponse.class)) {
            if (route.size() == 0) {
                createHelpResponse(bundle);
                bundle.getResponse().setState(CommandState.SUCCESS);
            } else {
                bundle.getResponse()
                    .updateEmbed(embed -> {
                        embed.setTitle("Please specify one of these sub commands for help with the " + node.getKey() + " command:");
                        embed.setDescription(ListFormatter.collectionToString(node.getChildKeys(), string -> "`" + string + "`", 99, "", ", "));
                        embed.setFooter(AudyMain.getVersion(), null);
                    })
                    .setState(CommandState.FAILED_EXPECTED);
            }
        // Found a command, get its config and print help information
        } else {
            String prefix = bundle.getGuildPrefix().map(s -> s + " ").orElse("");
            bundle.getResponse().updateEmbed(embed -> {
                embed.setTitle("Command: `" + prefix + String.join(" ", route) + "`");
                // Add help fields
                for (Pair<String, String> pair : node.getValue().getHelpFields()) {
                    embed.addField(pair.getKey().replaceAll("%p", prefix), pair.getValue().replaceAll("%p", prefix), false);
                }
                // Don't attach permissions to private commands, they won't exist
                if (bundle.getGuild().isPresent()) {
                    // Add required permissions
                    embed.addField("Required " + AudyClient.getClient().getSelfUsername() + " permissions:",
                            "```" + ListFormatter.collectionToString(node.getValue().getBotPermissions(), EnumFormattedName::getFormattedName, 99, "none", "\n") + "```",
                            true);
                    embed.addField("Required user permissions:",
                            "```" + ListFormatter.collectionToString(node.getValue().getMemberPermissions(), EnumFormattedName::getFormattedName, 99, "none", "\n") + "```",
                            true);
                }
                embed.setFooter(AudyMain.getVersion(), null);
            });
            bundle.getResponse().setState(CommandState.SUCCESS);
        }

        return Mono.empty();
    }

    /**
     * Update the bundle response with available commands.
     * @param bundle the bundle from the calling command
     */
    private void createHelpResponse(MessageBundle bundle) {
        Stream<CommandTreeNode> configurations = getRootNodeForListener(bundle.getGuild().isPresent())
            .getChildrenValues()
            .stream()
            .filter(node -> node.category != CommandCategory.Hidden); // Remove hidden command branches

        // TODO: Mark commands that can't be used instead of removing them?
        // Don't filter out unusable commands if the all flag is specified, ParserResult is always present
        //noinspection OptionalGetWithoutIsPresent
        if (!bundle.getParserResult().get().hasArg("all") && bundle.getGuild().isPresent() && bundle.getMember().isPresent()) {
            // Filter out commands that can't be used due to missing permissions.
            configurations = configurations
                .filter(node -> node.getValue()
                    .getMissingMemberPermissions(bundle.getMember().get().getBasePermissions().block()).isEmpty())
                .filter(node -> node.getValue()
                    .getMissingBotPermissions(bundle.getGuild().get()).isEmpty());
        }

        List<CommandTreeNode> availableCommands = configurations.collect(Collectors.toList());
        CodeBlock list = new CodeBlock().setCodeType("INI");
        for (CommandCategory category : CommandCategory.values()) {
            List<CommandTreeNode> entries = availableCommands.stream()
                .filter(node -> node.category == category)
                .collect(Collectors.toList());

            if (entries.size() > 0) {
                list.append("[ ").append(category.toString()).append(" ]").newLine()
                    .append(ListFormatter.collectionToString(entries, CommandTreeNode::getKey, 99, "none"))
                    .newLine().newLine();
            }
        }

        String prefix = bundle.getGuildPrefix().map(s -> s + " ").orElse("");
        bundle.getResponse().updateEmbed(embed -> {
            embed.setTitle("Command reference, use `" + prefix + "help <command>` to get help for a command.");
            embed.setDescription(list.toString());
            embed.setFooter(AudyMain.getVersion(), null);
        });
    }

    private CommandTreeNode getRootNodeForListener(boolean isGuild) {
        return  (isGuild)
            ? GuildCommandListener.get().getCommandTreeNode(new ArgsList(Collections.emptyList()))
            : DirectCommandListener.get().getCommandTreeNode(new ArgsList(Collections.emptyList()));
    }

    private CommandTreeNode getNodeForListener(boolean isGuild, ArgsList argsList) {
        return  (isGuild)
            ? GuildCommandListener.get().getCommandTreeNode(argsList)
            : DirectCommandListener.get().getCommandTreeNode(argsList);
    }
}
