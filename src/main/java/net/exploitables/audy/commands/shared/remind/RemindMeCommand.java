/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.commands.shared.remind;

import discord4j.core.object.entity.Message;
import net.exploitables.audy.commands.CommandState;
import net.exploitables.audy.commands.MessageBundle;
import net.exploitables.audy.commands.arguments.ArgumentParser;
import net.exploitables.audy.commands.arguments.RemindMeArguments;
import net.exploitables.audy.data.CommandConfig;
import net.exploitables.audy.data.CommandConfigBuilder;
import net.exploitables.audy.utilities.TimeFormatter;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.Duration;
import org.quartz.JobDataMap;
import org.quartz.SchedulerException;
import reactor.core.publisher.Mono;

public class RemindMeCommand extends RemindSuperCommand {
    private static RemindMeCommand singleton;

    // Command Configuration and reference to the command method.
    private CommandConfig commandConfig;

    /**
     * Create a new "TestCommand" command and configure it.
     */
    private RemindMeCommand() {
        this.commandConfig = new CommandConfigBuilder(this::remindMeCommand, this.getClass())
            .setArgumentParser(RemindMeArguments.getInstance())
            .addHelp("Description",
                "Setup a reminder that will be sent as a direct message to you a single time with a link to where " +
                "this command was called.")
            .addHelp("%premind me <time> [message]",
                "Get a link to where this command is used after the specified amount of time has passed. If a " +
                "message is supplied then it will be attached with the reminder.")
            .addHelp("Time Format",
                "Specify the amount of time by using a combination of the following with no spaces:\n" +
                "- **w**eeks\n" +
                "- **d**ays\n" +
                "- **h**ours\n" +
                "- **m**inutes\n\n" +
                "Example: `1w3d` is 10 days, `10d12h` is 10 days and 12 hours, `1h30m` is an hour and 30 " +
                "minutes.\nThe minimum amount of time is 1 hour, and the maximum is 30 days.")
            .addHelp("Arguments",
                "For advanced usage this command also supports arguments, such as specifying a date and time, or " +
                "repeating the reminder.\n\nTo see what arguments are available use this command with the `--help`" +
                " argument. Ex: `%premind me --help`")
            .build();
    }

    public static RemindMeCommand get() {
        if (singleton == null) singleton = new RemindMeCommand();
        return singleton;
    }

    public Mono<Void> remindMeCommand(MessageBundle bundle) {
        //noinspection OptionalGetWithoutIsPresent
        ArgumentParser parserResult = bundle.getParserResult().get();
        try {
            if (!super.isUnderReminderLimit(bundle)) {
                return Mono.empty();
            }

            if (parserResult.hasArg("in")) {
                int minutes = (int) parserResult.getArg("in");
                return createReminder(bundle, new DateTime().plusMinutes(minutes));
            } else if (parserResult.hasArg("time") || parserResult.hasArg("date")) {
                DateTime targetDate = (DateTime) parserResult.getArg("date");
                DateTime targetTime = (DateTime) parserResult.getArg("time");
                targetTime = super.combineDateTimes(targetDate, targetTime);

                if (targetTime.isBefore(DateTime.now())) {
                    bundle.getResponse().setState(CommandState.FAILED_EXPECTED)
                        .setContentTitle("Cannot set a reminder that occurs before the current time!");
                    return Mono.empty();
                }

                return createReminder(bundle, targetTime);
            } else {
                bundle.getResponse().setState(CommandState.FAILED_EXPECTED)
                    .setContentTitle("Please specify the duration you wish to be reminded in, see `" +
                        bundle.getGuildPrefix().map(s -> s + " ").orElse("") + "help remind me` for help.");
            }
        } catch (SchedulerException se) {
            bundle.getResponse().setThrowable(se);
        }

        return Mono.empty();
    }

    private Mono<Void> createReminder(MessageBundle bundle, DateTime reminderTime)
            throws SchedulerException {
        long minutes = new Duration(DateTime.now(), reminderTime).getMillis() / 1000;
        if (minutes >= 60 && minutes <= 44640) {
            // Make sure the duration isn't shorter than an hour or longer than 31 days
            // This limit is arbitrary, but the lower limit should be kept in mind as to not have the bot used
            //  as a glorified timer.

            // This is the only way (as of 2021-02-05) to tell if we can send private messages to a user
            //  try and fail
            Message privateTestMessage = bundle
                    .getAuthor()
                    .getPrivateChannel()
                    .flatMap(channel -> channel.createMessage("Placeholder to check if I can DM you."))
                    .onErrorResume(t -> Mono.empty())
                    .block();

            // Make sure we can DM the user
            if (privateTestMessage == null) {
                bundle.getResponse().setContentTitle(bundle.getAuthor().getMention() +
                        " I cannot message you directly. Please check your privacy settings and try again.");
                bundle.getResponse().setState(CommandState.FAILED_EXPECTED);
                return Mono.empty();
            }

            // Data to pair with the job for accessibility during execution
            JobDataMap reminderData = new JobDataMap();
            reminderData.put("creatingUserId", bundle.getAuthor().getId().asString());
            reminderData.put("creatingChannelId", bundle.getChannelId().asString());
            if (bundle.getGuild().isPresent())
                reminderData.put("creatingGuildId", bundle.getGuild().get().getId().asString());
            reminderData.put("creatingMessageId", bundle.getMessageId().asString());
            reminderData.put("destinationChannelId", privateTestMessage.getChannelId().asString());
            //noinspection OptionalGetWithoutIsPresent
            if (bundle.getParserResult().get().hasArg("message")) {
                reminderData.put("message", bundle.getParserResult().get().getArg("message"));
            }

            String name = bundle.getAuthor().getId().asString() + "-" + reminderTime.hashCode();
            super.scheduleReminderOnce(reminderData, name, createGroupForUser(bundle), reminderTime);

            // DM the calling user about the created reminder, checked we could send messages earlier
            String dateString = TimeFormatter.format(reminderTime
                    .withZone(DateTimeZone.forID(bundle.getUserConfig().getTimeZone())));
            privateTestMessage.edit(editSpec ->
                    editSpec.setContent("Your reminder hs been created, I'll send you another " +
                            "message here at `" + dateString + "`"))
                    .block();

            // Respond to the calling channel if in a guild
            if (bundle.getGuild().isPresent()) {
                bundle.getResponse()
                        .setContentTitle("Scheduled new reminder for `" + TimeFormatter.formatUTC(reminderTime) + "`")
                        .setState(CommandState.SUCCESS);
            } else {
                bundle.getResponse().setState(CommandState.SUCCESS_NO_SEND);
            }
        } else {
            bundle.getResponse().setContentTitle("Only durations of more than 1 hour or less than 30 days are supported.");
            bundle.getResponse().setState(CommandState.FAILED_EXPECTED);
        }
        return Mono.empty();
    }

    public CommandConfig getCommandConfig() {
        return this.commandConfig;
    }
}
