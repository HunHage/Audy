/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.commands.arguments;

import net.exploitables.audy.internal.ArgsList;
import net.exploitables.audy.internal.DetailedThrowable;
import net.exploitables.audy.internal.ThrowableReport;

import java.util.*;

public class ArgumentParser {
    ArgumentSet argSet;
    Map<String, Object> argValues;

    /**
     * Create a result with empty argument values. Called when parsing is successful.
     */
    public ArgumentParser(ArgumentSet argSet) {
        this.argSet = argSet;
        this.argValues = new HashMap<>();
    }

    /**
     * Parse the remaining terms in an ArgsList for arguments related to the ArgumentParser.
     *
     * @param argsList the argsList related to a command call with the current position set to after the command
     */
    public ArgumentParser parseArgs(ArgsList argsList) throws ArgParseException {
        String currentArg = argsList.getCurrent();
        if (currentArg != null && !argsList.getCurrent().startsWith("-")) {
            parsePositionalArgs(argsList);
        } else {
            //while ((currentArg = argsList.getCurrent()) != null) {
            while (currentArg != null) {
                argsList.advance();
                // Check for longOpt first as shortOpt will be true for longOpt
                if (currentArg.startsWith("--")) {
                    // Remove the hyphens
                    currentArg = currentArg.substring(2);
                    processLongArgument(currentArg, argsList);
                } else if (currentArg.startsWith("-")) { // Check for shortOpt
                    // Remove the hyphen
                    currentArg = currentArg.substring(1);
                    processShortArguments(currentArg, argsList);
                } else {
                    // Actual parsing error, ArgsList state is preserved.
                    new ThrowableReport(new DetailedThrowable("Bad state within ArgumentParser!")
                            .addAdditionalMessage("argsList", argsList.toString())
                            .addAdditionalMessage("argMap", argValues.toString())
                            .addAdditionalMessage("currentArg", currentArg))
                        .reportException();
                    throw new ArgParseException("Internal Argument Parsing Exception");
                }

                currentArg = argsList.getCurrent();
            }
        }
        return this;
    }

    private void processLongArgument(String arg, ArgsList argsList) throws ArgParseException {
        Optional<Argument> argument = argSet.arguments.getArgumentByLongOpt(arg);
        if (argument.isPresent()) {
            // Add the argument and it's parameter to the argMap
            argValues.put(arg, parseParameter(argsList, argument.get()));
        } else {
            throw new ArgParseException("No argument found for: " + arg);
        }
    }

    private void processShortArguments(String args, ArgsList argsList) throws ArgParseException {
        for (int i = 0; i < args.length(); i++) {
            char sOpt = args.charAt(i);
            Optional<Argument> argument = argSet.arguments.getArgumentByShortOpt(args);
            if (argument.isPresent()) {
                // Make sure an arg that needs a parameter value isn't put before the end
                if (argument.get().hasParameter()) {
                    if (i != args.length() - 1) {
                        throw new ArgParseException("A parameter must be specified for the " +
                            "short argument '" + sOpt + "'. Please place it at the end of the group or " +
                            "specify it separately to provide a parameter after it.");
                    }
                }
                argValues.put(argument.get().getLongOpt(), parseParameter(argsList, argument.get()));
            } else {
                throw new ArgParseException("Unknown short argument '" + sOpt + "' in: " + args);
            }
        }
    }

    /**
     * Parse positional arguments from the args list. While this function is public it should only
     * @param argsList the {@link ArgsList} containing the list of arguments from a message
     * @throws ArgParseException when no value is provided for a positional argument that has a parameter
     */
    private void parsePositionalArgs(ArgsList argsList) throws ArgParseException {
        // The positionalArguments field will be left null if no positional arguments are set
        if (argSet.positionalArguments == null) {
            throw new ArgParseException("Positional arguments are not supported for this command!");
        } else {
            // For each positional argument
            for (ArgumentPosition ap : argSet.positionalArguments) {
                // Get the next amount of args depending on the specified value
                String combined = argsList.combineNext(ap.count);
                if (combined == null && ap.argument.hasParameter()) {
                    throw new ArgParseException("No value provided for: " + ap.argument.getLongOpt());
                } else {
                    try {
                        argValues.put(ap.argument.getLongOpt(), ap.argument.parseArgument(combined));
                    } catch (Throwable t) {
                        throw new ArgParseException("Couldn't parse value '" + combined + "' for argument '"
                            + ap.argument.getLongOpt() + "'! Reason: " + t.getMessage(), t);
                    }
                }
            }
        }
    }

    /**
     * Parse the parameter value from the argsList, using either the next argument or the end of the argsList
     *  as the end of the parameter value.
     *
     * Precondition:  The argsList internal position should be at the term immediately following the term
     *                used to determine the argument
     * Postcondition: The argsList internal position will be set to the term immediately following the last
     *                term processed into the argument value, either the next term that may be an argument or
     *                the end of the argsList.
     * @param argsList the argsList to parse the parameter value from
     * @param argument the {@link Argument} specified which requires a parameter
     * @return an object created from the {@link Argument}s defined parsing method
     * @throws ArgParseException when no value found for an {@link Argument} which has a parameter
     */
    private Object parseParameter(ArgsList argsList, Argument argument) throws ArgParseException {
        List<String> params = new ArrayList<>();

        String current;
        while ((current = argsList.getCurrent()) != null) {
            if (!current.startsWith("-")) {
                params.add(current);
                argsList.advance();
            } else {
                break;
            }
        }

        if (params.isEmpty() && argument.hasParameter()) {
            throw new ArgParseException("No value found for: " + argument.getLongOpt());
        } else {
            // If the argument has no required parameter then the parameter will be discarded, turned into null
            String param = String.join(" ", params);
            try {
                return argument.parseArgument(param);
            } catch (Throwable t) {
                throw new ArgParseException("Couldn't parse value '" + param + "' for argument '"
                        + argument.getLongOpt() + "'! Reason: " + t.getMessage(), t);
            }
        }
    }

    /**
     * Safely cast the value to the desired class;
     *
     * @param longOpt the argument to get the value of
     * @param clazz the class of what the value should be
     * @return empty if the argument has no value, or the instance casted if successful
     * @throws ClassCastException if the value cannot be cast to the specified class
     */
    public <T> Optional<T> castValue(String longOpt, Class<T> clazz) {
        // Should have no cases where we don't return within CommandListener when an error occurs
        //noinspection ConstantConditions
        Object value = argValues.getOrDefault(longOpt, null);

        if (value != null) {
            if (clazz.isAssignableFrom(value.getClass())) {
                return Optional.of(clazz.cast(value));
            } else {
                throw new ClassCastException("Could not cast argument! Argument: '" + longOpt +
                    "' Class: '" + clazz.getSimpleName() + "'");
            }
        }

        return Optional.empty();
    }

    public boolean hasArg(String key) { return argValues.containsKey(key); }
    public Object  getArg(String key) { return argValues.get(key); }
}
