/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.commands.arguments;

import net.exploitables.audy.internal.ArgsList;
import net.exploitables.audy.internal.DetailedThrowable;
import net.exploitables.audy.internal.ThrowableReport;

import java.util.*;

public class ArgumentParser {
    ArgumentSet argSet;
    Map<String, Object> argValues;

    /**
     * Create a result with empty argument values. Called when parsing is successful.
     */
    public ArgumentParser() {
        this.argSet = new ArgumentSet();
        this.argValues = new HashMap<>();
    }

    public ArgumentParser(ArgumentSet argSet) {
        this.argSet = argSet;
        this.argValues = new HashMap<>();
    }

    /**
     * Parse the remaining terms in an ArgsList for arguments related to the ArgumentParser.
     *
     * @param argsList the argsList related to a command call with the current position set to after the command
     */
    public ArgumentParser parseArgs(ArgsList argsList) throws ArgParseException {
        String currentArg = argsList.getCurrent();
        if (currentArg != null && !argsList.getCurrent().startsWith("-")) {
            parsePositionalArgs(argsList);
        } else {
            //while ((currentArg = argsList.getCurrent()) != null) {
            while (currentArg != null) {
                argsList.advance();
                // Check for longOpt first as shortOpt will be true for longOpt
                if (currentArg.startsWith("--")) {
                    // Remove the hyphens
                    currentArg = currentArg.substring(2);
                    processLongArgument(currentArg, argsList);
                } else if (currentArg.startsWith("-")) { // Check for shortOpt
                    // Remove the hyphen
                    currentArg = currentArg.substring(1);
                    for (int i = 0; i < currentArg.length(); i++) {
                        char sOpt = currentArg.charAt(i);
                        Optional<Argument> argument = argSet.arguments.getArgumentByShortOpt(currentArg);
                        if (argument.isPresent()) {
                            // Add the argument and it's parameter to the argMap
                            // Since shortOpts can be grouped together into one term we only parse the value for the last
                            if (i == currentArg.length() - 1) {
                                argValues.put(argument.get().getLongOpt(), parseParameter(argsList, argument.get()));
                            } else {
                                if (argument.get().hasParameter()) {
                                    throw new ArgParseException("A parameter must be specified for the " +
                                            "short argument '" + sOpt + "'. Please place it at the end of the group or " +
                                            "specify it separately to provide a parameter after it.");
                                }
                                // Add the long opt of the argument to the map for clarity and consistent access
                                argValues.put(argument.get().getLongOpt(), null);
                            }
                        } else {
                            throw new ArgParseException("Unknown short argument '" + sOpt + "' in: " + currentArg);
                        }
                    }
                } else {
                    // Actual parsing error, ArgsList state is preserved.
                    new ThrowableReport(new DetailedThrowable("Bad state within ArgumentParser!")
                            .addAdditionalMessage("argsList", argsList.toString())
                            .addAdditionalMessage("argMap", argValues.toString())
                            .addAdditionalMessage("currentArg", currentArg))
                        .reportException();
                    throw new ArgParseException("Internal Argument Parsing Exception");
                }

                currentArg = argsList.getCurrent();
            }
        }
        return this;
    }

    private void processLongArgument(String arg, ArgsList argsList) throws ArgParseException {
        Optional<Argument> argument = argSet.arguments.getArgumentByLongOpt(arg);
        if (argument.isPresent()) {
            // Add the argument and it's parameter to the argMap
            argValues.put(arg, parseParameter(argsList, argument.get()));
        } else {
            throw new ArgParseException("No argument found for: " + arg);
        }
    }

    /**
     * Parse positional arguments from the args list. While this function is public it should only
     * @param argsList
     */
    private void parsePositionalArgs(ArgsList argsList) throws ArgParseException {
        if (argSet.positionalArguments == null) {
            throw new ArgParseException("Positional arguments are not supported for this command!");
        } else {
            for (ArgumentPosition ap : argSet.positionalArguments) {
                String combined = argsList.combineNext(ap.count);
                if (combined == null) {
                    throw new ArgParseException("No value provided for: " + ap.argument.getLongOpt());
                } else {
                    argValues.put(ap.argument.getLongOpt(), ap.argument.parseArgument(combined));
                }
            }
        }
    }

    /**
     * Parse the parameter value from the argsList, advancing as needed.
     * Precondition:  The argsList internal position should be at the term immediately following the term
     *                used to determine the argument
     * Postcondition: The argsList internal position will be set to the term immediately following the last
     *                term processed into the argument value, either the next term that may be an argument or
     *                the end of the argsList.
     * @param argsList the argsList to parse the parameter value from
     * @param argument the {@link Argument} specified which requires a parameter
     * @return an object created from the
     */
    private Object parseParameter(ArgsList argsList, Argument argument) throws ArgParseException {
        List<String> params = new ArrayList<>();

        String current;
        while ((current = argsList.getCurrent()) != null) {
            if (!current.startsWith("-")) {
                params.add(current);
                argsList.advance();
            } else {
                break;
            }
        }

        if (!params.isEmpty() || !argument.hasParameter()) {
            // If the argument has no required parameter then the parameter will be discarded, turned into null
            return argument.parseArgument(String.join(" ", params));
        } else {
            throw new ArgParseException("No value found for: " + argument.getLongOpt());
        }
    }

    /**
     * Safely cast the value to the desired class;
     *
     * @param longOpt the argument to get the value of
     * @param clazz the class of what the value should be
     * @return empty if the argument has no value, or the instance casted if successful
     * @throws ClassCastException if the value cannot be cast to the specified class
     */
    public <T> Optional<T> castValue(String longOpt, Class<T> clazz) {
        // Should have no cases where we don't return within CommandListener when an error occurs
        //noinspection ConstantConditions
        Object value = argValues.getOrDefault(longOpt, null);

        if (value != null) {
            if (clazz.isAssignableFrom(value.getClass())) {
                return Optional.of(clazz.cast(value));
            } else {
                throw new ClassCastException("Could not cast argument! Argument: '" + longOpt +
                    "' Class: '" + clazz.getSimpleName() + "'");
            }
        }

        return Optional.empty();
    }

    public boolean hasArg(String key) { return argValues.containsKey(key); }
    public Object  getArg(String key) { return argValues.get(key); }
}
