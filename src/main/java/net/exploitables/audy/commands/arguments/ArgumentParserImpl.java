package net.exploitables.audy.commands.arguments;

import net.exploitables.audy.data.Pair;
import net.exploitables.audy.internal.ArgsList;
import net.exploitables.audy.internal.DetailedThrowable;
import net.exploitables.audy.internal.ThrowableReport;
import net.exploitables.audy.utilities.CodeBlock;

import java.util.*;

/**
 * A collection of Arguments (List)
 */
public class ArgumentParserImpl implements ArgumentParser {
    Arguments arguments;

    // Create a new ArgumentParser class with a default help argument
    public ArgumentParserImpl() {
        arguments = new Arguments();
        arguments.add(new ArgumentBuilder("h", "help", "show help").build());
    }

    /**
     * Parse the remaining terms in an ArgsList for arguments related to the ArgumentParser.
     *
     * @param argsList the argsList related to a command call with the current position set to after the command
     * @return a Pair of a String with any error messages and a Map of the longOpt of the argument.
     *         If an error was encountered then the string will be present and the map will be null.
     *         If parsing was successful then the string will be null and the map will be present.
     */
    public Pair<String, Map<String, Object>> parseArgs(ArgsList argsList) {
        Map<String, Object> argMap = new HashMap<>();

        String currentArg;
        while ((currentArg = argsList.getCurrent()) != null) {
            argsList.advance();
            // Check for longOpt first as shortOpt will be true for longOpt
            if (currentArg.startsWith("--")) {
                // Remove the hyphens
                currentArg = currentArg.substring(2);
                Optional<Argument> argument = arguments.getArgumentByLongOpt(currentArg);
                if (argument.isPresent()) {
                    // Add the argument and it's parameter to the argMap
                    argMap.put(currentArg, parseParameter(argsList, argument.get()));
                } else {
                    return new Pair<>("Unknown long argument: " + currentArg, null);
                }
            } else if (currentArg.startsWith("-")) { // Check for shortOpt
                // Remove the hyphen
                currentArg = currentArg.substring(1);
                for (int i = 0; i < currentArg.length(); i++) {
                    char sOpt = currentArg.charAt(i);
                    Optional<Argument> argument = arguments.getArgumentByShortOpt(currentArg);
                    if (argument.isPresent()) {
                        // Add the argument and it's parameter to the argMap
                        // Since shortOpts can be grouped together into one term we only parse the value for the last
                        if (i == currentArg.length() - 1) {
                            argMap.put(argument.get().getLongOpt(), parseParameter(argsList, argument.get()));
                        } else {
                            if (argument.get().hasParameter()) {
                                return new Pair<>("A parameter must be specified for the short argument '" + sOpt +
                                    "'. Please place it at the end of the group or specify it separately to provide" +
                                    " a parameter after it.", null);
                            }
                            // Add the long opt of the argument to the map for clarity and consistent access
                            argMap.put(argument.get().getLongOpt(), null);
                        }
                    } else {
                        return new Pair<>("Unknown short argument '" + sOpt + "' in: " + currentArg, null);
                    }
                }
            } else {
                // Actual parsing error, return null for both fields to indicate this. ArgsList state is preserved.
                new ThrowableReport(new DetailedThrowable("Bad state within ArgumentParser!")
                        .addAdditionalMessage("argsList", argsList.toString())
                        .addAdditionalMessage("argMap", argMap.toString())
                        .addAdditionalMessage("currentArg", currentArg))
                    .reportException()
                    .block();
                return new Pair<>(null, null);
            }
        }

        return new Pair<>(null, argMap);
    }

    /**
     * Parse the parameter value from the argsList, advancing as needed.
     * Precondition:  The argsList internal position should be at the term immediately following the term
     *                used to determine the argument
     * Postcondition: The argsList internal position will be set to the term immediately following the last
     *                term processed into the argument value, either the next term that may be an argument or
     *                the end of the argsList.
     * @param argsList the argsList to parse the parameter value from
     * @param argument the {@link Argument} specified which requires a parameter
     * @return an object created from the
     */
    private Object parseParameter(ArgsList argsList, Argument argument) {
        List<String> params = new ArrayList<>();

        String current;
        while ((current = argsList.getCurrent()) != null) {
            if (!current.startsWith("-")) {
                params.add(current);
                argsList.advance();
            } else {
                break;
            }
        }

        // If the argument has no required parameter then the parameter will be discarded
        return argument.parseArgument(String.join(" ", params));
    }

    public String getHelp() {
        List<Pair<String, String>> definitions = new ArrayList<>();
        for (Argument argument : arguments) {
            StringBuilder sb = new StringBuilder();
            sb.append("[");
            // Append the shortOpt and longOpt
            sb.append(" -").append(argument.getShortOpt())
                .append(",  --").append(argument.getLongOpt());

            if (argument.hasParameter())
                sb.append(" ").append(argument.getParameterName());

            if (argument.isRequired())
                sb.append(" *");

            sb.append(" ]");
            definitions.add(new Pair<>(sb.toString(), argument.getDescription()));
        }

        int longWidth = definitions.stream()
                .max(Comparator.comparing(pair -> pair.getKey().length()))
                .orElse(definitions.get(0))
                .getKey()
                .length();
        CodeBlock manip = new CodeBlock().setCodeType("ini");
        for (Pair<String, String> pair : definitions) {
            manip.setW(longWidth).append(pair.getKey()).append(" ").append(pair.getValue()).newLine();
        }

        return manip.toString();
    }
}
