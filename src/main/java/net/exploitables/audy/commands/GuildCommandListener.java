/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.commands;

import discord4j.common.util.Snowflake;
import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.object.entity.Guild;
import discord4j.core.object.entity.Member;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.User;
import discord4j.core.spec.EmbedCreateSpec;
import net.exploitables.audy.AudyClient;
import net.exploitables.audy.AudyMain;
import net.exploitables.audy.commands.arguments.ArgParseException;
import net.exploitables.audy.commands.arguments.ArgumentParser;
import net.exploitables.audy.commands.guild.DefaultResponse;
import net.exploitables.audy.commands.guild.TestCommand;
import net.exploitables.audy.commands.guild.config.GuildPrefixCommand;
import net.exploitables.audy.commands.guild.info.InfoChannelCommand;
import net.exploitables.audy.commands.guild.info.InfoGuildCommand;
import net.exploitables.audy.commands.guild.info.InfoRoleCommand;
import net.exploitables.audy.commands.guild.info.InfoUserCommand;
import net.exploitables.audy.commands.guild.remind.RemindDeleteAll;
import net.exploitables.audy.commands.guild.remind.RemindMeOnceCommand;
import net.exploitables.audy.commands.shared.HelpCommand;
import net.exploitables.audy.commands.shared.PingCommand;
import net.exploitables.audy.data.CommandCategory;
import net.exploitables.audy.data.DiscordPermission;
import net.exploitables.audy.data.Pair;
import net.exploitables.audy.data.entity.GuildConfigFactory;
import net.exploitables.audy.internal.ArgsList;
import net.exploitables.audy.internal.DetailedThrowable;
import net.exploitables.audy.internal.ThrowableReport;
import net.exploitables.audy.internal.tree.CommandTree;
import net.exploitables.audy.internal.tree.CommandTreeNode;
import net.exploitables.audy.utilities.ListFormatter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.EnumSet;
import java.util.Map;
import java.util.function.Consumer;

public class GuildCommandListener {
    private static final Logger logger = LoggerFactory.getLogger(GuildCommandListener.class);
    private static GuildCommandListener singleton = null;

    // Enum used when evaluating how to respond to potential commands
    enum PermissionState {
        NO_SEND,
        NO_PERMS,
        ALL_PERMS
    }

    private Map<Long, String> guildPrefixMap;
    private CommandTree commandTree;

    private GuildCommandListener() {
        // Get all known guild prefixes from SQL, only storing id/prefix if a custom prefix is set
        guildPrefixMap = GuildConfigFactory.getAllGuildPrefixes();
        // Initialize the command tree with the default command response
        commandTree = new CommandTree(DefaultResponse.get().getCommandConfig());

        // ##### SQL Required for Functionality #####
        if (AudyMain.getConfiguration().isSqlEnabled()) {
            // Remind Commands
            commandTree.addTopLevelChild(DefaultResponse.get().getCommandConfig(),   "remind", CommandCategory.Hidden);
            commandTree.addChildByRoute(RemindMeOnceCommand.get().getCommandConfig(),"remind", "me", "once");
            commandTree.addChildByRoute(RemindDeleteAll.get().getCommandConfig(),    "remind", "delete");
            // Configuration Commands
            commandTree.addTopLevelChild(DefaultResponse.get().getCommandConfig(),   "config", CommandCategory.Configuration);
            commandTree.addChildByRoute(GuildPrefixCommand.get().getCommandConfig(), "config", "guild", "prefix");
        }
        // ##### SQL Optional for Functionality #####
        // Help
        commandTree.addTopLevelChild(HelpCommand.get().getCommandConfig(),       "help", CommandCategory.Help);
        // Info Commands
        commandTree.addTopLevelChild(DefaultResponse.get().getCommandConfig(),   "info", CommandCategory.Information);
        commandTree.addChildByRoute(InfoUserCommand.get().getCommandConfig(),    "info", "user");
        commandTree.addChildByRoute(InfoChannelCommand.get().getCommandConfig(), "info", "channel");
        commandTree.addChildByRoute(InfoRoleCommand.get().getCommandConfig(),    "info", "role");
        commandTree.addChildByRoute(InfoGuildCommand.get().getCommandConfig(),   "info", "guild");
        // Miscelaneous
        commandTree.addTopLevelChild(PingCommand.get().getCommandConfig(),       "ping", CommandCategory.Miscellaneous);

        // Test Command
        commandTree.addChildByRoute(TestCommand.get().getCommandConfig(),        "test");
    }

    public static GuildCommandListener get() {
        if (singleton == null) singleton = new GuildCommandListener();
        return singleton;
    }

    /**
     * Receive a new MessageCreateEvent from the gateway and handle it with the presumption it is a command.
     * @param event event representing a newly created message
     * @return the Message sent in reply to the command, empty if not a command, required data is missing, or the
     *  command responded in a custom way.
     */
    public Mono<Message> receiveMessageCreateEvent(MessageCreateEvent event) {
        // Immediately check if this is a guild command, guild id will be missing if event isn't from a guild
        String guildPrefix = event.getGuildId()
            .map(Snowflake::asLong)
            .map(this::getGuildPrefix)
            .filter(prefix -> startsWithPrefix(event.getMessage().getContent(), prefix))
            .orElse(null);

        // Guild prefix is only missing when the guild id isn't available
        if (guildPrefix == null) return Mono.empty();

        // Create a bundle builder, this will be null if the event is missing data needed for a guild command
        MessageBundleBuilder mbb = MessageBundleBuilder.createBuilderForGuildEvent(event).block();

        if (mbb != null) {
            mbb.guildPrefix = guildPrefix;
            // Parse the message content into an ArgsList
            mbb.argsList = ArgsList.fromGuildMessageContent(event.getMessage().getContent(), guildPrefix);
            // Get the command to be called, leaving the current index of ArgsList at the first term after the command
            mbb.commandNode = commandTree.getNodeByRoute(mbb.argsList);

            // Check permissions, return if missing
            Pair<PermissionState, Consumer<EmbedCreateSpec>> permCheck = checkPerms(mbb.commandNode, mbb.guild, mbb.member);
            // No message send permissions, return
            if (permCheck.getKey().equals(PermissionState.NO_SEND)) {
                return Mono.empty();
            // Missing permissions, send and return the supplied message
            } else if (permCheck.getKey().equals(PermissionState.NO_PERMS)) {
                return mbb.channel.createEmbed(permCheck.getValue());
            }

            // Parse the args if needed
            if (mbb.commandNode.getValue().getArgumentParser().isPresent()) {
                mbb.argumentParser = new ArgumentParser(mbb.commandNode.getValue().getArgumentParser().get());
                try {
                    mbb.argumentParser.parseArgs(mbb.argsList);
                } catch (ArgParseException ape) {
                    return mbb.channel.createMessage("Unable to parse arguments, please try again! `" + ape.getMessage() + "`");
                }
            }

            // Build the MessageBundle and execute the command
            MessageBundle messageBundle = mbb.build().block();
            try {
                //noinspection ConstantConditions
                messageBundle.executeCommand().block();
            } catch (Throwable throwable) {
                messageBundle.getResponse().setThrowable(throwable);
            }

            // Reply to the Calling User based on the CommandState
            CommandResponse response = messageBundle.getResponse();
            // An expected or handled error occurred, respond with the accompanying error message
            if (response.getState().notifyError()) {
                // Commands should always set their state and a message/embed
                if (response.getState() == CommandState.UNKNOWN) {
                    response.setThrowable(new DetailedThrowable("CommandStateUnknown").addEventLog(event));
                }
                new ThrowableReport(response.getThrowable()).reportException().block();
                return messageBundle.channel.createMessage(response.asMessage());
            // Command ran successfully, respond with the contents of CommandState
            } else if (response.getState().shouldRespond()) {
                return messageBundle.channel.createMessage(messageBundle.getResponse().asMessage());
            // Command ran successfully and replied to the Calling User in it's own way.
            } else {
                return Mono.empty();
            }
        } else {
            // Send back the prefix if the author pinged the bot and included the word "help"
            if (event.getMessage().getUserMentionIds().contains(event.getClient().getSelfId())
                    && event.getMessage().getContent().toLowerCase().contains("help")) {
                return event.getMessage().getChannel().flatMap(channel -> channel.createMessage("I'm listening for " +
                        "the prefix `" + guildPrefix + "` here!"));
            }
        }

        // Return empty if not a command
        return Mono.empty();
    }

    /**
     * Check if the Bot and Calling user have the required permissions to execute the command
     * @param node the CommandTree node for the command
     * @param guild the guild the command was called in
     * @param member the Calling User
     * @return a pair of the PermissionsState, and a MessageCreateSpec if permissions are missing when messages can be sent
     */
    private Pair<PermissionState, Consumer<EmbedCreateSpec>> checkPerms(CommandTreeNode node, Guild guild, Member member) {
        // Check command permissions for Calling User and Bot
        EnumSet<DiscordPermission> missingBotPerms = node.getValue().getMissingBotPermissions(guild);
        EnumSet<DiscordPermission> missingUserPerms = node.getValue().getMissingMemberPermissions(member.getBasePermissions().block());

        // Bot doesn't have permissions to send messages back to the same channel
        if (missingBotPerms.contains(DiscordPermission.SEND_MESSAGES)) return new Pair<>(PermissionState.NO_SEND, null);
        if (!missingBotPerms.isEmpty() || !missingUserPerms.isEmpty()) {
            Consumer<EmbedCreateSpec> embed = (spec) -> {
                spec.setTitle("Permissions Missing!");
                spec.setDescription("There are permissions missing for you to use the `" + String.join(" ", node.getRoute()) + "` command.");
                if (!missingBotPerms.isEmpty()) {
                    String selfUsername = AudyClient.getClient().getGateway().getSelf()
                        .map(User::getUsername)
                        .blockOptional()
                        .orElse("Audy");
                    spec.addField("I (" + selfUsername + ") need these permissions:",
                        "```" + ListFormatter.collectionToString(missingBotPerms, DiscordPermission::getFormattedName, 99, "none", "\n") + "```",
                        true);
                }
                if (!missingUserPerms.isEmpty()) {
                    spec.addField("You (" + member.getDisplayName() + ") need these permissions:",
                        "```" + ListFormatter.collectionToString(missingBotPerms, DiscordPermission::getFormattedName, 99, "none", "\n") + "```",
                        true);
                }
            };

            return new Pair<>(PermissionState.NO_PERMS, embed);
        } else {
            return new Pair<>(PermissionState.ALL_PERMS, null);
        }
    }

    /**
     * Check of the provided string starts with the bot prefix.
     * @param content content of the message to check for the prefix
     * @param prefix the guild prefix to check for
     * @return true if content starts with prefix ignoring case, false otherwise
     */
    private boolean startsWithPrefix(String content, String prefix) {
        // Prevent IndexOutOfBounds exception
        if (prefix.length() > content.length()) return false;
        return content.substring(0, prefix.length()).equalsIgnoreCase(prefix);
    }

    /**
     * Update a guild prefix immediately. Called when a command is used to change the guild prefix.
     * If prefix is null then the guild went back to the default prefix and the entry in the map will be removed.
     * @param guildId the id of the guild
     * @param prefix the new prefix to listen for in the guild
     */
    public void updateGuildPrefix(Long guildId, String prefix) {
        if (prefix != null) {
            guildPrefixMap.put(guildId, prefix);
        } else {
            guildPrefixMap.remove(guildId);
        }
    }

    /**
     * Get the prefix a guild is set to, returns a custom prefix or the default.
     * @param guildId guild id to get the prefix of
     */
    public String getGuildPrefix(Long guildId) {
        return guildPrefixMap.getOrDefault(guildId, AudyMain.getConfiguration().getDefaultPrefix());
    }

    public CommandTreeNode getCommandTreeNode(ArgsList argsList) {
        return commandTree.getNodeByRoute(argsList);
    }
}
