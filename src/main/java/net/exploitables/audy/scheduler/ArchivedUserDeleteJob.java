/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.scheduler;

import net.exploitables.audy.AudyDatabase;
import net.exploitables.audy.AudyMain;
import org.quartz.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.Instant;

public class ArchivedUserDeleteJob implements Job {
    private static Logger logger = LoggerFactory.getLogger(ArchivedUserDeleteJob.class);

    public static void scheduleJobs(Scheduler scheduler) throws SchedulerException {
        logger.info("Scheduling ArchivedMessageDeleteJob for scheduler: " + scheduler.getSchedulerName());
        JobDetail jobDetail = JobBuilder
            .newJob(ArchivedUserDeleteJob.class)
            .withIdentity("ArchivedUserDelete", "SqlMaintenance")
            .build();
        SimpleTrigger trigger = (SimpleTrigger) TriggerBuilder
            .newTrigger()
            .withIdentity("ArchivedUserDelete", "SqlMaintenance")
            // This means there may be a full 2 hour delay before starting the job, or only a few seconds.
            // This job runs at a minimum of every hour, so this should be OK as if the bot doesn't have the
            //  uptime to execute a job within the next 2 hours consistently there are larger problems afoot.
            .startAt(DateBuilder.evenHourDateAfterNow())
            .withSchedule(SimpleScheduleBuilder.repeatHourlyForever(AudyMain.getConfiguration().getUserDataRetentionInterval()))
            .build();

        scheduler.scheduleJob(jobDetail, trigger);

        logger.info("ArchivedUserDeleteJob scheduled for: " + scheduler.getSchedulerName());
    }

    /**
     * Delete old entries in the ArchivedMessagesTable every Hour.
     * @param context unused for this job
     * @throws JobExecutionException
     */
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        logger.info("Executing scheduled job to delete ArchivedUser entries ...");
        long pastThreshold = Instant.now()
            .minus(Duration.ofHours(AudyMain.getConfiguration().getUserDataRetentionHours()))
            .toEpochMilli();

        // Delete all history entries before attempting to delete latest entries.
        // Could theoretically execute a cascade delete however we do not want to remove data within the threshold.
        int rowsDeleted = AudyDatabase.getJdbi().withHandle(handle ->
            handle.createUpdate("DELETE FROM tbl_user_history" +
                " WHERE timestamp < :pastThreshold;")
                .bind("pastThreshold", pastThreshold)
                .execute()
            );
        rowsDeleted += AudyDatabase.getJdbi().withHandle(handle ->
            handle.createUpdate("DELETE FROM tbl_user_history_latest" +
                " WHERE timestamp < :pastThreshold;")
                .bind("pastThreshold", pastThreshold)
                .execute()
        );

        logger.info("Removed " + rowsDeleted + " rows after deleting old ArchivedUser entries.");
    }
}
