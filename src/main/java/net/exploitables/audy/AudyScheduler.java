package net.exploitables.audy;

import net.exploitables.audy.internal.ThrowableReport;
import net.exploitables.audy.scheduler.ArchivedFileDeleteJob;
import net.exploitables.audy.scheduler.ArchivedMessageDeleteJob;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.impl.StdSchedulerFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Properties;

public class AudyScheduler {
    private static final Logger logger = LoggerFactory.getLogger(AudyScheduler.class);

    private static Scheduler ramScheduler;
    private static Scheduler sqlRemindScheduler;

    /**
     * Called during application startup to setup schedulers, this does *not* start them as jobs may require
     *  Discord API access and this is not intended to be called after login when the gateway is open.
     */
    static void setupSchedulers() {
        logger.info("Setting up schedulers ...");
        try {
            ramScheduler = StdSchedulerFactory.getDefaultScheduler();
            setupRamJobs();

            StdSchedulerFactory sf = new StdSchedulerFactory(createSqlSchedulerProperties());
            sqlRemindScheduler = sf.getScheduler();

            logger.info("Schedulers setup.");
        } catch (SchedulerException se) {
            new ThrowableReport(se).reportInternalException().block();
            System.exit(-1);
        }
    }

    /**
     * Startup schedulers, this should be called AFTER opening the Discord gateway as jobs will utilize it.
     * @return true if startup succeeded, false if an exception was encountered.
     */
    static boolean startSchedulers() {
        logger.info("Starting schedulers ...");
        try {
            ramScheduler.start();
            sqlRemindScheduler.start();
            logger.info("Schedulers started.");
            return true;
        } catch (SchedulerException se) {
            new ThrowableReport(se).reportInternalException();
            return false;
        }
    }

    /**
     * Shutdown schedulers, this should be called BEFORE closing the Discord gateway as jobs within the next
     *  half hour will be executed so they are not missed.
     *
     * Down the line the amount of time to execute ahead should be increased.
     * @param minutesAhead the amount of minutes ahead to execute jobs in order to not miss them during downtime
     */
    static void stopSchedulers(int minutesAhead) {
        logger.info("Stopping schedulers (and waiting for current jobs to complete) ...");
        try {
            ramScheduler.shutdown(true);
            sqlRemindScheduler.shutdown(true);
            logger.info("Schedulers stopped.");
        } catch (SchedulerException se) {
            new ThrowableReport(se).reportInternalException().block();
        }
//        // TODO: Should a persistent time be set for when the scheduler should start on next app start?
//        // TODO: In addition, on startup that time should be set to cover any missed jobs.
//        try {
//            long lastSqlTime = Instant.now().toEpochMilli();
//            if (minutesAhead > 0) {
//                logger.info("Minutes Ahead is non-zero, executing jobs that will occur within the next" +
//                        minutesAhead + " minutes ...");
//                // We need to determine and properly store the last time events within the scheduler will execute.
//                lastSqlTime = Instant.now().toEpochMilli() + (minutesAhead * 60000);// 60s * 1000ms
//                executeUpcomingJobs(lastSqlTime, ramScheduler);
//                executeUpcomingJobs(lastSqlTime, sqlRemindScheduler);
//            }
//            ramScheduler.shutdown(true);
//            sqlRemindScheduler.shutdown(true);
//            setSqlLastQtzRmdTime(lastSqlTime);
//        } catch (SchedulerException se) {
//            new ThrowableReport(se).reportInternalException().block();
//        }
    }

    /**
     * Setup and register static RAM jobs.
     */
    private static void setupRamJobs() {
        try {
            if (AudyMain.getConfiguration().isSqlEnabled()) {
                ArchivedMessageDeleteJob.scheduleJobs(ramScheduler);
                ArchivedFileDeleteJob.scheduleJobs(ramScheduler);
            }
        } catch (SchedulerException se) {
            new ThrowableReport(se).reportInternalException().block();
        }
    }

//    /**
//     * Put the scheduler on standby and execute upcoming jobs within the time provided.
//     * This is called by {@code #stopSchedulers()} on each scheduler in use.
//     *
//     * @param aheadTime the threshold of time to execute tasks early as an epoch milli
//     * @param scheduler the scheduler to retrieve and execute jobs for
//     */
//    private static void executeUpcomingJobs(long aheadTime, Scheduler scheduler) throws SchedulerException {
//        logger.info("Executing future jobs for scheduler: " + scheduler.getSchedulerName());
//        long now = Instant.now().toEpochMilli();
//        // Stop the scheduler from executing tasks while we check the ones we want to execute
//        // This prevents a task from executing that's scheduled a small amount of time ahead, that could be
//        //  passed while we are checking jobs.
//        scheduler.standby();
//
//        // Get all job keys from the ram scheduler. Then get all triggers for the jobs to see if they will
//        //  execute within the provided minutesAhead
//        Set<JobKey> jobKeys = scheduler.getJobKeys(GroupMatcher.anyJobGroup());
//        logger.info("Checking " + jobKeys.size() + " jobs for execution ...");
//        for (JobKey jobKey : jobKeys) {
//            logger.debug("Checking next job with JobKey: " + jobKey.getName());
//            List<? extends Trigger> triggers = scheduler.getTriggersOfJob(jobKey);
//            for (Trigger trigger : triggers) {
//                logger.debug("Checking next trigger for " + jobKey + " ...");
//                long nextFireTime = trigger.getNextFireTime().toInstant().toEpochMilli();
//                if (nextFireTime < aheadTime && nextFireTime > now) {
//                    logger.info("Firing job: " + jobKey.getName());
//                    scheduler.triggerJob(jobKey);
//                    break; // We don't need to check other triggers if they exist
//                }
//            }
//        }
//        logger.info("Done executing future jobs for scheduler: " + scheduler.getSchedulerName());
//    }

    /**
     * Create the properties for the Reminder Scheduler to connect to the SQL database for job storage.
     * @return a configuration to initialize the Reminder Scheduler
     */
    private static Properties createSqlSchedulerProperties() {
        Properties p = new Properties();

        // Identification
        p.put("org.quartz.scheduler.instanceName",              "QuartzSqlRemindScheduler");
        p.put("org.quartz.scheduler.instanceId",                "AUTO");
        // Thread Pool
        p.put("org.quartz.threadPool.class",                    "org.quartz.simpl.SimpleThreadPool");
        p.put("org.quartz.threadPool.threadCount",              "3");
        // Data Source, this identifies the AudyDatabaseConnectionProvider class as
        p.put("org.quartz.dataSource.AudySqlDataSource.connectionProvider.class",
                "net.exploitables.audy.scheduler.AudyDatabaseConnectionProvider");
        // Connection to SQL
        p.put("org.quartz.jobStore.class",                      "org.quartz.impl.jdbcjobstore.JobStoreTX");
        p.put("org.quartz.jobStore.driverDelegateClass",        "org.quartz.impl.jdbcjobstore.PostgreSQLDelegate");
        p.put("org.quartz.jobStore.dataSource",                 "AudySqlDataSource");
        p.put("org.quartz.jobStore.tablePrefix",                "tbl_qtz_rmd_");
        return p;
    }

//    /**
//     * Update the last time that jobs within the quartz reminder scheduler were executed.
//     * @param lastQtzRmdTime the earliest time that the reminder scheduler should execute jobs again.
//     */
//    private static void setSqlLastQtzRmdTime(long lastQtzRmdTime) {
//        AudyDatabase.getJdbi().useHandle(handle ->
//            handle.createUpdate("UPDATE tlb_audy_persistence SET" +
//                " last_qtz_rmd_time = :last_qtz_rmd_time" +
//                " WHERE" +
//                " pk_id = 0" +
//                " ;")
//            .bind("last_qtz_time", lastQtzRmdTime)
//            .execute()
//        );
//    }
//
//    /**
//     * Get the last time that jobs within the quartz reminder scheduler were executed.
//     * @return  the earliest time that the reminder scheduler should execute jobs again.
//     */
//    private static long getSqlLastQtzRmdTime() {
//        return AudyDatabase.getJdbi().withHandle(handle ->
//            handle.createQuery("SELECT * FROM tbl_audy_persistence" +
//                " WHERE" +
//                " pk_id = 0" +
//                " ;")
//                .map(rowView -> rowView.getColumn("last_qtz_rmd_time", Long.class))
//                .findOne()
//                .orElse(0L)
//        );
//    }
}
