/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy;

import discord4j.common.util.Snowflake;
import discord4j.core.DiscordClient;
import discord4j.core.GatewayDiscordClient;
import discord4j.core.event.EventDispatcher;
import discord4j.core.event.domain.Event;
import discord4j.core.event.domain.PresenceUpdateEvent;
import discord4j.core.event.domain.guild.GuildCreateEvent;
import discord4j.core.event.domain.guild.MemberUpdateEvent;
import discord4j.core.event.domain.message.MessageBulkDeleteEvent;
import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.event.domain.message.MessageDeleteEvent;
import discord4j.core.event.domain.message.MessageUpdateEvent;
import discord4j.core.object.presence.Activity;
import discord4j.core.object.presence.Presence;
import discord4j.discordjson.json.MessageData;
import net.exploitables.audy.commands.GuildCommandListener;
import net.exploitables.audy.data.entity.GuildConfigFactory;
import net.exploitables.audy.data.history.ArchivedMemberFactory;
import net.exploitables.audy.data.history.ArchivedMessageFactory;
import net.exploitables.audy.data.history.ArchivedUserFactory;
import net.exploitables.audy.internal.ThrowableReport;
import org.reactivestreams.Publisher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.function.Function;

public class AudyClient {
    private static final Logger logger = LoggerFactory.getLogger(AudyClient.class);
    private static AudyClient singleton;

    // Discord Client Parts
    private final DiscordClient client;
    private EventDispatcher eventDispatcher;
    private GatewayDiscordClient gateway;
    // Bot login information, retrieved after login, not updated so can de-sync
    private Snowflake selfId;
    private String username;

    /**
     * Create a DiscordClient which represents the base for all other Discord classes.
     */
    private AudyClient() {
        this.client = DiscordClient.create(AudyMain.getToken());
    }

    /**
     * Register a method to be called when a Discord event comes through.
     *
     * @param eventClass the event class to listen for
     * @param mapper the action to take on every new event
     * @param <E> a D4J event representing an event delivered from Discord
     * @param <R> the return type wrapped within a {@link Mono}
     */
    private <E extends Event, R> void onDiscordEvent(Class<E> eventClass,
                                                     Function<? super E, Publisher<? extends R>> mapper) {
        eventDispatcher.on(eventClass)
            .flatMap(mapper)
            .onErrorContinue((throwable, o) -> {
                // If something goes wrong when reporting an exception (writing file and/or sending message)
                // then fall back to logging to standard output
                try {
                    new ThrowableReport(throwable).reportException();
                } catch (Exception exception) {
                    exception.initCause(throwable);
                    new ThrowableReport(exception).reportInternalException();
                }
            })
            .subscribe();
    }

    /**
     * As of D4J v3.1.0 {@link GatewayDiscordClient#onDisconnect()} will not emit a value until the bot
     *  disconnects from discord *completely*, calling .block() will cause the thread to stop until that happens.
     */
    public void blockUntilDisconnect() {
        this.gateway.onDisconnect().block();
    }

    /**
     * Send a Message to the specified channel ID without needing to be logged in, or more importantly without needing
     *  a cached {@link discord4j.core.object.entity.channel.MessageChannel} instance for the channel.
     *
     * @param channelId channel id to send the message to
     * @param content content of the message to send
     */
    public Mono<MessageData> sendMessageToChannel(Snowflake channelId, String content) {
       return this.getDiscordClient().getChannelById(channelId).createMessage(content);
    }

    /**
     * Fully create a new AudyClient by creating a new instance,
     *  creating a DiscordClient, registering event subscribers,
     *  and logging in to retrieve a GatewayDiscordClient
     * @return a fully built {@link AudyClient} instance
     */
    private static AudyClient createAudyClient() {
        logger.info("Starting Audy " + AudyMain.getVersion());
        logger.info("Creating Discord client ...");
        AudyClient audyClient = new AudyClient();

        logger.info("Registering event subscribers ...");
        audyClient.eventDispatcher = EventDispatcher.builder().build();

        // ##### SQL Required for Functionality #####
        if (AudyMain.getConfiguration().isSqlEnabled()) {
            // Guild Welcome
            audyClient.onDiscordEvent(GuildCreateEvent.class, GuildConfigFactory::onGuildCreateEvent);
            // ArchivedMessageFactory
            audyClient.onDiscordEvent(MessageCreateEvent.class, ArchivedMessageFactory::receiveMessageCreateEvent);
            audyClient.onDiscordEvent(MessageUpdateEvent.class, ArchivedMessageFactory::receiveMessageUpdateEvent);
            audyClient.onDiscordEvent(MessageDeleteEvent.class, ArchivedMessageFactory::receiveMessageDeleteEvent);
            audyClient.onDiscordEvent(MessageBulkDeleteEvent.class, ArchivedMessageFactory::receiveMessageBulkDeleteEvent);
            // ArchivedUserFactory
            audyClient.onDiscordEvent(PresenceUpdateEvent.class, ArchivedUserFactory::receiveUserUpdateEvent);
            // ArchivedMemberFactory
            audyClient.onDiscordEvent(MemberUpdateEvent.class, ArchivedMemberFactory::receiveMemberUpdateEvent);
        }
        // ##### SQL Optional for Functionality #####
        // Commands
        audyClient.onDiscordEvent(MessageCreateEvent.class, GuildCommandListener.get()::receiveMessageCreateEvent);

        logger.info("Logging in ...");
        audyClient.gateway = audyClient.client.gateway().setEventDispatcher(audyClient.eventDispatcher).login().block();
        // TODO: Not sure if Bots can simply set a status without "listening to ...", see D4J issue #644?
        //noinspection ConstantConditions
        audyClient.gateway.updatePresence(Presence.online(Activity.listening("@Audy help for prefix!"))).block();
        audyClient.selfId = audyClient.gateway.getSelfId();
        //noinspection ConstantConditions
        audyClient.username = audyClient.gateway.getSelf().block().getUsername();
        //noinspection ConstantConditions
        logger.info("Logged in successfully as " + audyClient.username + "#" +
                audyClient.gateway.getSelf().block().getDiscriminator() + "! ID:" + audyClient.selfId.asString() + "");
        logger.info("Audy " + AudyMain.getVersion() + " started successfully!");

        return audyClient;
    }

    /**
     * Get or create a singleton instance for all related DiscordClient instances.
     * When the singleton is created a connection to Discord will be made, and the bot will log in.
     * @return the singleton instance
     */
    public static AudyClient getClient() {
        if (singleton == null) {
            singleton = createAudyClient();
        }
        return singleton;
    }

    public DiscordClient getDiscordClient()     { return this.client; }
    public GatewayDiscordClient getGateway()    { return this.gateway; }
    public Snowflake getSelfId()                { return this.selfId; }
    public String getSelfUsername()             { return this.username; }
}
