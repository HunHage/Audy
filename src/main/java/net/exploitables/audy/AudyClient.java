package net.exploitables.audy;

import discord4j.common.util.Snowflake;
import discord4j.core.DiscordClient;
import discord4j.core.GatewayDiscordClient;
import discord4j.core.event.EventDispatcher;
import discord4j.core.event.domain.Event;
import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.discordjson.json.MessageData;
import net.exploitables.audy.internal.ThrowableReport;
import net.exploitables.audy.subscribers.CommandListener;
import org.reactivestreams.Publisher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.function.Function;

public class AudyClient {
    private static final Logger logger = LoggerFactory.getLogger(AudyClient.class);
    private static AudyClient singleton;

    // Discord Client Parts
    private final DiscordClient client;
    private EventDispatcher eventDispatcher;
    private GatewayDiscordClient gateway;
    // Bot login information, retrieved after login, not updated so can de-sync
    private Snowflake selfId;
    private String username;

    /**
     * Create a DiscordClient which represents the base for all other Discord classes.
     */
    private AudyClient() {
        this.client = DiscordClient.create(AudyMain.getToken());
    }

    /**
     * Register a method to be called when a Discord event comes through.
     *
     * @param eventClass the event class to listen for
     * @param mapper the action to take on every new event
     * @param <E> a D4J event representing an event delivered from Discord
     * @param <R> the return type wrapped within a {@link Mono}
     */
    private <E extends Event, R> void onDiscordEvent(Class<E> eventClass,
                                                     Function<? super E, Publisher<? extends R>> mapper) {
        eventDispatcher.on(eventClass)
                .flatMap(mapper)
                .onErrorResume(throwable -> new ThrowableReport(throwable).reportException())
                .subscribe();
    }

    /**
     * As of D4J v3.1.0 {@link GatewayDiscordClient#onDisconnect()} will not emit a value until the bot
     *  disconnects from discord *completely*, calling .block() will cause the thread to stop until that happens.
     */
    public void blockUntilDisconnect() {
        this.gateway.onDisconnect().block();
    }

    /**
     * Send a Message to the specified channel ID without needing to be logged in, or more importantly without needing
     *  a cached {@link discord4j.core.object.entity.channel.MessageChannel} instance for the channel.
     *
     * @param channelId channel id to send the message to
     * @param content content of the message to send
     */
    public Mono<MessageData> sendMessageToChannel(Snowflake channelId, String content) {
       return this.getDiscordClient().getChannelById(channelId).createMessage(content);
    }

    /**
     * Fully create a new AudyClient by creating a new instance,
     *  creating a DiscordClient, registering event subscribers,
     *  and logging in to retreive a GatewayDiscordClient
     * @return a fully built {@link AudyClient} instance
     */
    private static AudyClient createAudyClient() {
        logger.info("Creating Discord client ...");
        AudyClient audyClient = new AudyClient();

        logger.info("Registering event subscribers ...");
        audyClient.eventDispatcher = EventDispatcher.builder().build();
        audyClient.onDiscordEvent(MessageCreateEvent.class, CommandListener.getSingleton()::receiveMessageCreateEvent);

        logger.info("Logging in ...");
        audyClient.gateway = audyClient.client.gateway().setEventDispatcher(audyClient.eventDispatcher).login().block();
        //noinspection ConstantConditions
        audyClient.selfId = audyClient.gateway.getSelfId();
        //noinspection ConstantConditions
        logger.info("Logged in successfully as " + audyClient.gateway.getSelf().block().getUsername() +
                "#" + audyClient.gateway.getSelf().block().getDiscriminator() + "! ID:" + audyClient.selfId + "");

        return audyClient;
    }

    /**
     * Get or create a singleton instance for all related DiscordClient instances.
     * When the singleton is created a connection to Discord will be made, and the bot will log in.
     * @return the singleton instance
     */
    public static AudyClient getClient() {
        if (singleton == null) {
            singleton = createAudyClient();
        }
        return singleton;
    }

    public DiscordClient getDiscordClient()  { return this.client; }
    public GatewayDiscordClient getGateway()        { return this.gateway; }
    public Snowflake getSelfId()         { return this.selfId; }
    public String getSelfUsername()   { return this.username; }
}
