package net.exploitables.audy.data.entity;

import discord4j.core.object.entity.Guild;
import net.exploitables.audy.AudyDatabase;
import net.exploitables.audy.data.Pair;
import org.jdbi.v3.core.mapper.RowMapperFactory;
import org.jdbi.v3.core.mapper.reflect.ConstructorMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * Factory for {@link GuildConfig}.
 *
 * Various methods of obtaining data from SQL to construct instances as well as specific methods
 *  to access data in a particular way where an entire
 *
 * Many of the methods present return Mono for compatibility with reactor. The methods themselves
 *  are not reactive and do not benefit from Reactor. A database driver such as r2dbc would be needed.
 *  But for now, JDBI will likely suffice.
 */
public class GuildConfigFactory {
    private static final Logger logger = LoggerFactory.getLogger(GuildConfigFactory.class);
    private static final RowMapperFactory mapper = ConstructorMapper.factory(GuildConfig.class);

    /**
     * @param guild the guild to get saved configuration for
     * @return a GuildConfig instance representing data currently saved in SQL, created if needed
     *  errors are emitted through the mono
     */
    public static Mono<GuildConfig> getGuildConfigFromSQL(Guild guild) {
        try {
            logger.debug("Loading GuildConfig for ID:" + guild.getId().asLong() + " ...");
            Optional<GuildConfig> sqlData = AudyDatabase.getJdbi().withHandle(handle -> {
                handle.registerRowMapper(mapper);
                return handle.createQuery("SELECT * FROM guild_config WHERE guild_id = :guild_id")
                    .bind("guild_id", guild.getId().asLong())
                    .mapTo(GuildConfig.class)
                    .findOne();
            });

            if (sqlData.isPresent()) {
                logger.debug("GuildConfig for ID:" + guild.getId().asLong() + " retrieved.");
                return Mono.justOrEmpty(sqlData);
            } else {
                return createNewGuildConfig(guild);
            }
        } catch (Exception e) {
            return Mono.error(e);
        }
    }

    /**
     * Create a new {@link GuildConfig} for the provided guild and insert a row into the SQL database.
     * Should only be called when no entry for this guild exists.
     *
     * @param guild guild to create data for
     * @return a {@link GuildConfig} for the guild, otherwise an error is emitted through the mono
     */
    private static Mono<GuildConfig> createNewGuildConfig(Guild guild) {
        try {
            logger.debug("Creating GuildConfig for ID:" + guild.getId().asLong() + " ...");
            GuildConfig guildConfig = new GuildConfig(guild);
            AudyDatabase.getJdbi().useHandle(handle ->
                handle.createUpdate("INSERT INTO guild_config (" +
                    " guild_id," +
                    " joined," +
                    " prefix" +
                    " ) VALUES (" +
                    " :guild_id," +
                    " :joined," +
                    " :prefix" +
                    ");")
                    .bind("guild_id", guildConfig.getGuildId().asLong())
                    .bind("joined", guildConfig.hasJoined())
                    .bind("prefix", guildConfig.getPrefix())
                    .execute());
            logger.debug("Created GuildConfig for ID:" + guild.getId().asLong());
            return Mono.justOrEmpty(guildConfig);
        } catch (Exception e) {
            return Mono.error(e);
        }
    }

    /**
     * Save the provided {@link GuildConfig} to the SQL database.
     * @param config the {@link GuildConfig} to save all properties of
     * @return the provided {@link GuildConfig} on completion
     */
    public static Mono<GuildConfig> saveGuildConfigNow(GuildConfig config) {
        try {
            AudyDatabase.getJdbi().useHandle(handle ->
                handle.createUpdate("UPDATE guild_config" +
                    " SET" +
                    " joined = :joined," +
                    " prefix = :prefix" +
                    " WHERE" +
                    " guild_id = :guild_id")
                    .bind("joined", config.joined)
                    .bind("prefix", config.prefix)
                    .bind("guild_id", config.guild_id.asLong())
                    .execute());
            return Mono.just(config);
        } catch (Exception e) {
            return Mono.error(e);
        }
    }

    /**
     * Get the custom prefix for a single guild.
     * @param guildId snowflake id of the guild to get the prefix for
     * @return the prefix for the guild if it exists
     */
    public static Mono<String> getGuildPrefix(long guildId) {
        try {
            Optional<String> prefix = AudyDatabase.getJdbi().withHandle(handle ->
                handle.createQuery("SELECT guild_id, prefix FROM guild_config WHERE guild_id = :guild_id")
                    .bind("guild_id", guildId)
                    .mapTo(String.class)
                    .findOne());
            return Mono.justOrEmpty(prefix);
        } catch (Exception e) {
            return Mono.error(e);
        }
    }

    /**
     * Get all custom guild prefixes from SQL.
     * @return a newly created {@link HashMap} containing every guild ID with a custom prefix as the key
     */
    public static Map<Long, String> getAllGuildPrefixes() {
        HashMap<Long, String> prefixMap = new HashMap<>();
        AudyDatabase.getJdbi().useHandle(handle ->
            handle.createQuery("SELECT guild_id, prefix FROM guild_config")
            .map((rs, ctx) -> new Pair<>(rs.getLong("guild_id"), rs.getString("prefix")))
            .list()
            .forEach(pair -> {
                // If the guild has no custom prefix set then don't add it to the Map
                if (pair.getValue() != null) {
                    prefixMap.put(pair.getKey(), pair.getValue());
                }
            }));
        return prefixMap;
    }
}
