package net.exploitables.audy.data.history;

import net.exploitables.audy.AudyDatabase;
import org.jdbi.v3.core.mapper.reflect.ConstructorMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.beans.ConstructorProperties;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * A Class representing a column with SQL for a message saved from Discord.
 */
public class ArchivedMessage {
    private final Logger logger = LoggerFactory.getLogger(ArchivedMessage.class);

    /** Never null: The ID of the message */
    private final long messageId;
    /** Never null: The Guild this message was posted in */
    private final long guildId;
    /** Sometimes null: The Channel this message was posted in */
    Long channelId;
    /** Sometimes null: The User who created this message */
    Long authorId;

    /** Sometimes null: If the Message has content, either when created or edited to have content.
     * If this is true then there *will* be entries in SQL for {@link ArchivedMessageContent}. null when
     * it's only known that the Message is deleted*/
    Boolean hasContent;
    /** Sometimes null: If the message *content* has been edited by the poster, this will be true.
     * Otherwise false, if unknown then null.*/
    Boolean edited;
    /** Sometimes null: A List of {@link ArchivedMessageContent} entries for each known version
     * of this Messages content. null when respective data hasn't been fetched. */
    List<ArchivedMessageContent> contents;

    /** Sometimes null: If the Message has attachments, if this is true there *will* be entries.
     * in SQL for {@link ArchivedMessageAttachment}. null when it's only known that the Message is deleted. */
    Boolean hasAttachments;
    /** Sometimes null: A list of {@link ArchivedMessageAttachment} entries for each attachment this
     * message was uploaded with. null when respective data hasn't been fetched. */
    List<ArchivedMessageAttachment> attachments;

    /** Never null: If the Message is deleted then this will not be `0`. If this is `1` then
     *  The deletion time is unknown. */
    Long deletedTimestamp;

    /** Never null: The last event that modified this data. */
    ArchivedMessageSource lastSource;
    /** Never null: Flags about the message's previous states. */
    int messageFlags;

    /**
     * Initialize a new ArchivedMessage with the bare minimum data required.
     *
     * @param messageId ID of the Message
     * @param guildId ID o the Guild the Message was posted in
     */
    ArchivedMessage(long messageId, long guildId) {
        this.messageId = messageId;
        this.guildId = guildId;
        this.channelId = null;
        this.authorId = null;

        this.hasContent = false;
        this.contents = new ArrayList<>();
        this.edited = false;

        this.hasAttachments = false;
        this.attachments = new ArrayList<>();

        this.deletedTimestamp = 0L;

        this.lastSource = ArchivedMessageSource.MID;
        this.messageFlags = 0;
    }

    /**
     * Initialize a new ArchivedMessage with data from SQL.
     *
     * @param messageId         The id of the message as set by Discord.
     * @param guildId           The id of the guild the message was posted in.
     * @param channelId         The id of the channel the message was posted in.
     * @param authorId          The id of the author the message was posted by.
     * @param hasContent        If this message has content available in the database.
     * @param edited            If this message has been edited.
     * @param hasAttachments    If this message has attachments in the databse.
     * @param deletedTimestamp  When this message was deleted.
     * @param source            The last event to modify this data.
     * @param messageFlags      Flags set about the history of this data.
     */
    @ConstructorProperties({"pk_id", "guild_id", "channel_id", "author_id",
            "contents", "edited", "attachments",
            "deleted", "last_source", "flags"})
    public ArchivedMessage(long messageId, long guildId, long channelId, long authorId,
                    boolean hasContent, boolean edited, boolean hasAttachments,
                    long deletedTimestamp, String source, int messageFlags) {
        this.messageId = messageId;
        this.guildId = guildId;
        this.channelId = channelId;
        this.authorId = authorId;

        this.hasContent = hasContent;
        this.contents = (hasContent) ? null : new ArrayList<>();
        this.edited = edited;

        this.hasAttachments = hasAttachments;
        this.attachments = (hasAttachments) ? null : new ArrayList<>();

        this.deletedTimestamp = deletedTimestamp;

        this.lastSource = ArchivedMessageSource.valueOf(source);
        this.messageFlags = messageFlags;
    }

    /**
     * Add known contents to this Message. Either from the initial Message content or
     * from the Message being edited.
     * @param newContent new content generated by
     * @return the instance modified
     */
    ArchivedMessage addContent(ArchivedMessageContent newContent) {
        if (!this.hasContent) {
            this.hasContent = true;
        }
        this.contents.add(newContent);
        return this;
    }

    /**
     * Add an attachment to this Message
     * @param newAttachment attachment generated by {@link ArchivedMessageFactory}
     * @return the instance modified
     */
    ArchivedMessage addAttachment(ArchivedMessageAttachment newAttachment) {
        if (!this.hasAttachments) {
            this.hasAttachments = true;
        }
        this.attachments.add(newAttachment);
        return this;
    }

    /**
     * Create this in SQL, then create present Contents and Attachments in SQL as well.
     * @return this instance
     */
    ArchivedMessage createNow() {
        AudyDatabase.getJdbi().useHandle(handle -> {
            handle.createUpdate("INSERT INTO tbl_messages (" +
                " pk_id," +
                " guild_id," +
                " channel_id," +
                " author_id," +
                " contents," +
                " edited," +
                " attachments," +
                " deleted," +
                " last_source," +
                " flags" +
                " ) VALUES (" +
                " :pk_id," +
                " :guild_id," +
                " :channel_id," +
                " :author_id," +
                " :contents," +
                " :edited," +
                " :attachments," +
                " :deleted," +
                " :last_source," +
                " :flags" +
                ");")
                .bind("pk_id", this.messageId)
                .bind("guild_id", this.guildId)
                .bind("channel_id", this.channelId)
                .bind("author_id", this.authorId)
                .bind("contents", this.hasContent)
                .bind("edited", this.edited)
                .bind("attachments", this.hasAttachments)
                .bind("deleted", this.deletedTimestamp)
                .bind("last_source", this.lastSource.toString())
                .bind("flags", this.messageFlags)
                .execute();
        });

        // Create message contents and attachments in SQL now that the message exists for foreign keys.
        // This is not done when updating the message, as the keys already exist.
        for (ArchivedMessageContent content : contents) { content.createNow(); }
        for (ArchivedMessageAttachment attachment : attachments) { attachment.createNow(); }

        return this;
    }

    /**
     * Update this in SQL, then create present Contents and Attachments in SQL as well.
     * @return this instance
     */
    ArchivedMessage updateNow() {
        AudyDatabase.getJdbi().useHandle(handle -> {
            handle.createUpdate("UPDATE tbl_messages SET (" +
                " channel_id = :channel_id," +
                " author_id = :author_id," +
                " contents = :contents," +
                " edited = :edited," +
                " attachments = :attachments," +
                " deleted = :deleted," +
                " last_source = :last_source," +
                " flags = :flags" +
                " ) WHERE (" +
                " pk_id = :pk_id" +
                ");")
                .bind("pk_id", this.messageId)
                .bind("channel_id", this.channelId)
                .bind("author_id", this.authorId)
                .bind("contents", this.hasContent)
                .bind("edited", this.edited)
                .bind("attachments", this.attachments)
                .bind("deleted", this.deletedTimestamp)
                .bind("last_source", this.lastSource.toString())
                .bind("flags", this.messageFlags)
                .execute();
        });

        // We do not update the child contents or attachments.
        // The former is handled by ArchivedMessageFactory, the latter never happens.
        return this;
    }

    /**
     * Get a message by its id.
     * @param messageId the id of the message to retrieve
     * @return a newly created {@link ArchivedMessageContent} representing the row if it exists in SQL
     */
    public static Optional<ArchivedMessage> getById(long messageId) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedMessage.class));
            return handle.createQuery("SELECT * FROM tbl_messages WHERE" +
                " pk_id = :pk_id;")
                .bind("pk_id", messageId)
                .mapTo(ArchivedMessage.class)
                .findOne();
        });
    }

    /**
     * @return A 0-n list of all contents this message has been known to have. Sorted with oldest first.
     */
    public final List<ArchivedMessageContent> getContents() {
        // If contents haven't been fetched from SQL and they should exist then do so.
        if (contents == null) {
            contents = ArchivedMessageContent.getByMessageId(messageId);
            if (contents.isEmpty()) {
                logger.warn("ArchivedMessage indicated it had contents when it did not! Message ID: " + messageId);
            }
        }
        return contents;
    }

    /**
     * @return A 0-n list of all attachments this message has been known to have.
     */
    public final List<ArchivedMessageAttachment> getAttachments() {
        // If contents haven't been fetched from SQL and they should exist then do so.
        if (attachments == null) {
            attachments = ArchivedMessageAttachment.getAttachmentsByMessageId(messageId);
            if (attachments.isEmpty()) {
                logger.warn("ArchivedMessage indicated it had attachments when it did not! Message ID: " + messageId);
            }
        }
        return attachments;
    }

    public final long                   getMessageId()          { return messageId; }
    public final long                   getGuildId()            { return guildId; }
    public final long                   getChannelId()          { return channelId; }
    public final long                   getAuthorId()           { return authorId; }
    public final boolean                hasContent()            { return hasContent; }
    public final boolean                isEdited()              { return edited; }
    public final boolean                hasAttachments()        { return hasAttachments; }
    public final boolean                isDeleted()             { return deletedTimestamp != null; }
    public final Long                   getDeletedTimestamp()   { return deletedTimestamp; }
    public final ArchivedMessageSource  getLastSource()         { return lastSource; }
    public final int                    getMessageFlags()       { return messageFlags; }
}
