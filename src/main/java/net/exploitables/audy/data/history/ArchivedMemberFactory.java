package net.exploitables.audy.data.history;

import discord4j.core.event.domain.guild.MemberUpdateEvent;
import discord4j.core.object.entity.Member;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.Optional;

/**
 * Receive events about guild members and update SQL side data accordingly.
 * See {@link ArchivedUserFactory} for some explanation on how archived history data is stored in SQL.
 */
public class ArchivedMemberFactory {
    private static final Logger logger = LoggerFactory.getLogger(ArchivedMemberFactory.class);

    /**
     * Update member nickname for ArchivedMemberNickname and ArchivedMemberNicknameLatest.
     * @param event the event created when a member was updated as provided by D4J
     * @return an empty mono, errors are emitted through the mono
     */
    public static Mono<Void> receiveMemberUpdateEvent(MemberUpdateEvent event) {
        // Pretty important to have the Member for this event, later on the roles will be needed as well
        Member member = event.getMember().block();
        if (member == null) { return Mono.empty(); }

        // We treat no nickname as "" due to constraint with SQL design
        String nickname = event.getCurrentNickname().orElse("");
        Optional<ArchivedMember> archivedMember = ArchivedMember.getArchivedMember(member);

        // Data present, update it if needed
        if (archivedMember.isPresent()) {
            // If the nickname doesn't match our last known nickname
            if (!nickname.equals(archivedMember.get().latest.nickname)) {
                logger.debug("Logging new nickname for UserId: " + member.getId().asString() +
                    " GuildID: " + member.getGuildId().asString());
                ArchivedMemberEntry newEntry = new ArchivedMemberEntry(member);
                newEntry.nickname = archivedMember.get().latest.nickname;
                archivedMember.get().latest.nickname = nickname;
                // Update data in SQL
                newEntry.createNow();
                archivedMember.get().latest.updateNow();
            }
        } else { // No data present, create it
            logger.debug("Creating new ArchivedMember for UserId: " + member.getId().asString() +
                " GuildID: " + member.getGuildId().asString());
            return event.getMember()
                .flatMap(ArchivedMemberFactory::createNewArchivedMemberLatest)
                .map(ArchivedMemberLatest::createNow)
                .then();
        }

        return Mono.empty();
    }

    /**
     * Called when no previous data exists for a member.
     * @param member the {@link Member} to create an entry for in SQL
     * @return a new ArchivedUserLatest based on the provided user
     */
    private static Mono<ArchivedMemberLatest> createNewArchivedMemberLatest(Member member) {
        return Mono.just(new ArchivedMemberLatest(member));
    }
}
