package net.exploitables.audy.data.history;

import discord4j.core.event.domain.guild.MemberUpdateEvent;
import discord4j.core.object.entity.Member;
import reactor.core.publisher.Mono;

import java.util.Optional;

/**
 * Receive events about guild members and update SQL side data accordingly.
 * See {@link ArchivedUserFactory} for some explanation on how archived history data is stored in SQL.
 */
public class ArchivedMemberFactory {
    /**
     * Update member nickname for ArchivedMemberNickname and ArchivedMemberNicknameLatest.
     * @param event the event created when a member was updated as provided by D4J
     * @return an empty mono, errors are emitted through the mono
     */
    public static Mono<Void> receiveMemberUpdateEvent(MemberUpdateEvent event) {
        // Pretty important to have the Member for this event, later on the roles will be needed as well
        Member member = event.getMember().block();
        if (member == null) { return Mono.empty(); }

        Optional<String> nickname = event.getCurrentNickname();
        Optional<ArchivedMember> archivedMember = ArchivedMember.getArchivedMember(member);

        // Data present, update it if needed
        if (archivedMember.isPresent()) {
            boolean nicknameChanged = nickname
                .map(nn -> nn.equals(archivedMember.get().latest.nickname))
                .orElse(false);
            if (nicknameChanged) {
                ArchivedMemberEntry newEntry = new ArchivedMemberEntry(member);
                newEntry.nickname = archivedMember.get().latest.nickname;
                archivedMember.get().latest.nickname = nickname.orElse("");
            }
        } else { // No data present, create it
            return event.getMember()
                .flatMap(ArchivedMemberFactory::createNewArchivedMemberLatest)
                .map(ArchivedMemberLatest::createNow)
                .then();
        }

        return Mono.empty();
    }

    /**
     * Called when no previous data exists for a member.
     * @param member the {@link Member} to create an entry for in SQL
     * @return a new ArchivedUserLatest based on the provided user
     */
    private static Mono<ArchivedMemberLatest> createNewArchivedMemberLatest(Member member) {
        return Mono.just(new ArchivedMemberLatest(member));
    }
}
