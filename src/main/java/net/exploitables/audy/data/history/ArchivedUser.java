/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.data.history;

import net.exploitables.audy.AudyDatabase;
import org.jdbi.v3.core.mapper.reflect.ConstructorMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Optional;

/**
 * A representation of stored user data within SQL for previous Usernames, Discriminators, and Avatars.
 */
public class ArchivedUser {
    private static final Logger logger = LoggerFactory.getLogger(ArchivedUser.class);

    private final long userId;
    ArchivedUserLatest latest;
    //List<ArchivedUserEntry> history;

    /**
     * Create a new ArchivedUser from calling {@link ArchivedUser#getArchivedUser}.
     * @param userId the Snowflake ID uf the user this data represents.
     * @param latest the latest known state of the User's profile.
     */
    ArchivedUser(long userId, ArchivedUserLatest latest) {
        this.userId = userId;
        this.latest = latest;
    }

    /**
     * Get an ArchivedUser which can be used to interact with saved SQL data. If the latest entry doesn't exist then
     *  then by design there will be no saved data for this user at all.
     * @param userId the Discord Snowflake ID of the User to get profile history for.
     * @return A present {@link ArchivedUser} if SQL data is present, empty otherwise.
     */
    public static Optional<ArchivedUser> getArchivedUser(long userId) {
        Optional<ArchivedUserLatest> latest = AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedUserLatest.class));
            return handle.createQuery("SELECT * FROM tbl_user_history_latest WHERE" +
                " user_id = :user_id;")
                .bind("user_id", userId)
                .mapTo(ArchivedUserLatest.class)
                .findOne();
            });

        return latest.map(archivedUserEntry -> new ArchivedUser(userId, archivedUserEntry));
    }

    /**
     * Get an Archived File from SQL by it's MD5
     * @param md5 the MD5 of the file
     * @return a present optional of a representative {@link ArchivedFile} if available, empty otherwise
     */
    public static Optional<ArchivedFile> getByMD5(String md5) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedFile.class));
            return handle.createQuery("SELECT * FROM tbl_archived_user_latest WHERE" +
                "  = :pk_md5;")
                .bind("pk_md5", md5)
                .mapTo(ArchivedFile.class)
                .findOne();
        });
    }

    public long getUserId() { return userId; }
    public ArchivedUserLatest getLastKnownState() { return latest; }
}
