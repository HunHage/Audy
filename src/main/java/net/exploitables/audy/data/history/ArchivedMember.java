package net.exploitables.audy.data.history;

import discord4j.core.object.entity.Member;
import net.exploitables.audy.AudyDatabase;
import org.jdbi.v3.core.mapper.reflect.ConstructorMapper;

import java.util.Optional;

public class ArchivedMember {
    private final long userId;
    private final long guildId;
    ArchivedMemberLatest latest;
    //List<ArchivedMemberNicknameEntry> history;

    /**
     * Create a new ArchivedMember from calling {@link ArchivedMember#getArchivedMember(long userId, long guildId)}
     * @param userId the Snowflake ID of the user for the member this data represents
     * @param guildId the Snowflake ID of the guild for the member this data represents
     * @param latest the latest entry in SQL as represented by {@link ArchivedMemberLatest}
     */
    ArchivedMember(long userId, long guildId, ArchivedMemberLatest latest) {
        this.userId = userId;
        this.guildId = guildId;
        this.latest = latest;
    }

    /**
     * Get an ArchivedMember which can be used to interact with saved SQL data. If the latest entry doesn't exist then
     *  then by design there will be no saved data for this user at all.
     * @param userId the Snowflake ID of the User for the Member to get history for.
     * @return A present {@link ArchivedUser} if SQL data is present, empty otherwise.
     */
    public static Optional<ArchivedMember> getArchivedMember(long userId, long guildId) {
        Optional<ArchivedMemberLatest> latest = AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedMemberLatest.class));
            return handle.createQuery("SELECT * FROM tbl_member_history_latest WHERE" +
                " user_id = :user_id AND" +
                " guild_id = :guild_id;")
                .bind("user_id", userId)
                .bind("guild_id", guildId)
                .mapTo(ArchivedMemberLatest.class)
                .findOne();
        });

        return latest.map(archivedMemberEntry -> new ArchivedMember(userId, guildId, archivedMemberEntry));
    }

    /**
     * A helper function that calls {@link ArchivedMember#getArchivedMember(long userId, long guildId)}
     * @param member the member to get history for
     * @return A present {@link ArchivedUser} if SQL data is present, empty otherwise.
     */
    public static Optional<ArchivedMember> getArchivedMember(Member member) {
        return getArchivedMember(member.getId().asLong(), member.getGuildId().asLong());
    }

    public long                         getUserId()     { return userId; }
    public long                         getGuildId()    { return guildId; }
    public ArchivedMemberLatest getLatest()     { return latest; }
}
