/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.data.history;

import discord4j.core.event.domain.PresenceUpdateEvent;
import discord4j.core.object.entity.User;
import net.exploitables.audy.internal.ThrowableReport;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * A description on how the ArchivedUser system works:
 * There is a row within `tbl_user_history_latest` (latest) that contains the last known state of the user which
 *  should be current to their discord profile. When the user changes something on their profile then the
 *  latest entry us updated, and old columns are pushed as a row to `tbl_user_history` (history).
 *
 * This creates a system where we know part of the user's profile for a range in time up to the point it has been
 *  changed to something else. While this system has a rough edge for getting the latest (must also fetch the latest
 *  entry along with rows from history) it allows us to simply delete entries older than X days and not have to
 *  perform expensive queries ensuring we didn't delete an older entry in a system that records when a name was changed
 *  *to* instead of this system where we record when a name was changed *from*.
 *
 *  A graphical representation, the final row is the entry for latest. Blank means null
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * user_id * timestamp * username  * discriminator * avatar_md5  * avatar_name *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * 123     * 10000     * barry     *               *             *             * User changed their name from barry
 * 123     * 20000     *           * 1234          *             *             * User changed their discrim from 1234
 * 123     * 30000     * eugene    *               *             *             * User changed their name from eugene
 * 123     * 40000     * barr      *               *             *             * User changed their name from barr
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * 123     * 50000     * barry     * 5678          * abc123      * file.jpg    * Latest row
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 * At any point in time, the next newest entry will have the given property for the profile at that point in time.
 * Throughout the whole history the avatar has not changed. So when trying to get it the latest entry will have to be
 *  imposed on the history for a complete row of data.
 *
 * There are some oversights to this system as well. Since it's completely dependent on the user's presence updating
 *  it is possible to never log data for a user since they never go online (status set invisible) however this would
 *  simply mean that the history for their profile doesn't exist regardless and would just be their current profile
 *  for at least the length of the retention period.
 */
public class ArchivedUserFactory {
    private static final Logger logger = LoggerFactory.getLogger(ArchivedUserFactory.class);

    /**
     * Receive presence update events which include changes to the user's username, discriminator, and avatar.
     * This event is received any time the profile changes so checks should be performed to ensure that
     *
     * @param event a PresenceUpdateEvent from discord which contains the new state of a user
     * @return an empty mono
     */
    // Suppress this warning as it is detected in situations where we know data will be present due to SQL design.
    @SuppressWarnings("OptionalGetWithoutIsPresent")
    public static Mono<Void> receiveUserUpdateEvent(PresenceUpdateEvent event) {
        // Try and get saved data from SQL
        Optional<ArchivedUser> archivedUser = ArchivedUser.getArchivedUser(event.getUserId().asLong());
        ArchivedUserEntry newEntry = new ArchivedUserEntry(event.getUserId().asLong());
        AtomicBoolean changed = new AtomicBoolean(false);

        // We could use the `event.getNewXXX()` methods however the case where we have missed a user updating their
        //  profile would require us to check the user object anyway. So we will just do that instead since this event
        //  is received whenever their status changes.

        // If present, then check for differences
        if (archivedUser.isPresent()) {
            // Username is different than the last known in SQL.
            event.getUser().map(User::getUsername)
                .filter(nName -> !nName.equals(archivedUser.get().getLastKnownState().getUsername().get()))
                .flatMap(nName -> {
                    logger.debug("Logging new username for: " + event.getUserId().asString());
                    newEntry.username = archivedUser.get().latest.username;
                    archivedUser.get().latest.username = nName;
                    changed.set(true);
                    return Mono.empty();
                })
                .block();

            // Discriminator is different that the last known in SQL.
            event.getUser().map(User::getDiscriminator)
                .filter(nDisc -> !nDisc.equals(archivedUser.get().getLastKnownState().getUsername().get()))
                .flatMap(nDisc -> {
                    logger.debug("Logging new discriminator for: " + event.getUserId().asString());
                    newEntry.discriminator = archivedUser.get().latest.discriminator;
                    archivedUser.get().latest.discriminator = nDisc;
                    changed.set(true);
                    return Mono.empty();
                });

            // Sometimes we can get the MD5 hash of the file from D4J, in this case we cannot.
            // We can get the hash from PresenceUpdateEvent.getNewAvatar() however that invalidates the consistency
            //  of just checking the latest user information from within cache.
            String userAvatarUrl = event.getUser().map(User::getAvatarUrl).block();
            Optional<ArchivedFile> aFile = ArchivedFile.getByUrl(userAvatarUrl);

            // We have the URL of this file in the DB
            if (aFile.isPresent()) {
                // If the MD5 doesn't match our last known MD5 for the users avatar then simply update the MD5
                if (!aFile.get().getMD5().equals(archivedUser.get().latest.avatarMD5)) {
                    logger.debug("Logging new avatar (existing file) for: " + event.getUserId().asString());
                    newEntry.avatarMD5 = archivedUser.get().latest.avatarMD5;
                    archivedUser.get().latest.avatarMD5 = aFile.get().getMD5();
                    newEntry.avatarName = archivedUser.get().latest.avatarName;
                    try {
                        archivedUser.get().latest.avatarName = Paths.get(new URL(userAvatarUrl)
                            .getPath()).getFileName().toString();
                    } catch (MalformedURLException murle) {
                        archivedUser.get().latest.avatarName = "unknown";
                    }

                    changed.set(true);
                }
            } else { // We do not have the URL in the DB, we may or may not have the file entirely, need to check
                // This will download the file and add the URL to the DB for it
                String md5 = ArchivedFile.getMD5FromUrl(userAvatarUrl);

                // Ensure we got the file, not ideal to completely pass on failing a download, but the next
                //  presence update will call this logic again.
                if (md5 != null) {
                    // Avatar MD5 mismatch, new avatar
                    if (!md5.equals(archivedUser.get().latest.avatarMD5)) {
                        logger.debug("Logging new avatar (new file) for: " + event.getUserId().asString());
                        newEntry.avatarMD5 = archivedUser.get().latest.avatarMD5;
                        archivedUser.get().latest.avatarMD5 = md5;
                        newEntry.avatarName = archivedUser.get().latest.avatarName;
                        try {
                            archivedUser.get().latest.avatarName = Paths.get(new URL(userAvatarUrl)
                                    .getPath()).getFileName().toString();
                        } catch (MalformedURLException murle) {
                            archivedUser.get().latest.avatarName = "unknown";
                        }

                        changed.set(true);
                    }
                }
            }

            // Create the new entry if the user has updated their profile.
            if (changed.get()) {
                newEntry.createEntryNow();
                archivedUser.get().latest.timestamp = Instant.now().toEpochMilli();
                archivedUser.get().latest.updateEntryNow();
            }
        } else { // No latest entry available, create it.
            logger.debug("Creating new ArchivedUser for: " + event.getUserId().asString());
            return event.getUser()
                .flatMap(ArchivedUserFactory::createNewArchivedUser)
                .map(ArchivedUserLatest::createEntryNow)
                .then();
        }

        return Mono.empty();
    }

    /**
     * Called when no previous data exists for a user.
     * @param user the {@link User} to create an entry for in SQL
     * @return a new ArchivedUserLatest based on the provided user
     */
    private static Mono<ArchivedUserLatest> createNewArchivedUser(User user) {
        try {
            String userName = user.getUsername();
            String userDisc = user.getDiscriminator();
            String avatarMD5;
            String avatarName;

            avatarMD5 = ArchivedFile.getMD5FromUrl(user.getAvatarUrl());
            if (avatarMD5 == null) { throw new IOException("Couldn't download file from URL: " + user.getAvatarUrl()); }
            avatarName = Paths.get(new URL(user.getAvatarUrl()).getPath()).getFileName().toString();;

            return Mono.just(new ArchivedUserLatest(user.getId().asLong(), Instant.now().toEpochMilli(), userName, userDisc, avatarMD5, avatarName));
        } catch (IOException ioe) {
            return new ThrowableReport(ioe, "Error encountered while trying to download user avatar!").reportException();
        }
    }
}
