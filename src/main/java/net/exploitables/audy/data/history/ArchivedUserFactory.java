/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.data.history;

import discord4j.core.event.domain.PresenceUpdateEvent;
import discord4j.core.object.entity.User;
import net.exploitables.audy.internal.ThrowableReport;
import net.exploitables.audy.utilities.FileManager;
import org.apache.commons.codec.digest.DigestUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * A description on how the ArchivedUser system works:
 * There is a row within `tbl_user_history_latest` (latest) that contains the last known state of the user which
 *  should be current to their discord profile. When the user changes something on their profile then the
 *  latest entry us updated, and old columns are pushed as a row to `tbl_user_history` (history).
 *
 * This creates a system where we know part of the user's profile for a range in time up to the point it has been
 *  changed to something else. While this system has a rough edge for getting the latest (must also fetch the latest
 *  entry along with rows from history) it allows us to simply delete entries older than X days and not have to
 *  perform expensive queries ensuring we didn't delete an older entry in a system that records when a name was changed
 *  *to* instead of this system where we record when a name was changed *from*.
 *
 *  A graphical representation, the final row is the entry for latest. Blank means null
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * user_id * timestamp * username  * discriminator * avatar_md5  * avatar_name *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * 123     * 10000     * barry     *               *             *             * User changed their name from barry
 * 123     * 20000     *           * 1234          *             *             * User changed their discrim from 1234
 * 123     * 30000     * eugene    *               *             *             * User changed their name from eugene
 * 123     * 40000     * barry     *               *             *             * User changed their name to barry
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * 123     * N/A       * barry     * 1234          * abc123      * file.jpg    * Latest row
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 * At any point in time, the next newest entry will have the given property for the profile at that point in time.
 * Throughout the whole history the avatar has not changed. So when trying to get it the latest entry will have to be
 *  imposed on the history for a complete row of data.
 */
public class ArchivedUserFactory {
    private static final Logger logger = LoggerFactory.getLogger(ArchivedUserFactory.class);

    /**
     * Receive presence update events which include changes to the user's username, discriminator, and avatar.
     * This event is received any time the profile changes so checks should be performed to ensure that
     *
     * @param event a PresenceUpdateEvent from discord which contains the new state of a user
     * @return an empty mono
     */
    // Suppress this warning as it is detected in situations where we know data will be present due to SQL design.
    @SuppressWarnings("OptionalGetWithoutIsPresent")
    public static Mono<Void> receiveUserUpdateEvent(PresenceUpdateEvent event) {
        // Try and get saved data from SQL
        Optional<ArchivedUser> archivedUser = ArchivedUser.getArchivedUser(event.getUserId().asLong());
        ArchivedUserEntry newEntry = new ArchivedUserEntry(event.getUserId().asLong());
        AtomicBoolean changed = new AtomicBoolean(false);

        // We could use the `event.getNewXXX()` methods however the case where we have missed a user updating their
        //  profile would require us to check the user object anyway. So we will just do that instead since this event
        //  is received whenever their status changes.

        // If present, then check for differences
        if (archivedUser.isPresent()) {
            // Username is different than the last known in SQL.
            event.getUser().map(User::getUsername)
                .filter(nName -> !nName.equals(archivedUser.get().getLastKnownState().getUsername().get()))
                .flatMap(nName -> {
                    newEntry.username = archivedUser.get().latest.username;
                    archivedUser.get().latest.username = nName;
                    changed.set(true);
                    return Mono.empty();
                })
                .block();

            // Discriminator is different that the last known in SQL.
            event.getUser().map(User::getDiscriminator)
                .filter(nDisc -> !nDisc.equals(archivedUser.get().getLastKnownState().getUsername().get()))
                .flatMap(nDisc -> {
                    newEntry.discriminator = archivedUser.get().latest.discriminator;
                    archivedUser.get().latest.discriminator = nDisc;
                    changed.set(true);
                    return Mono.empty();
                });

            // Sometimes we can get the MD5 hash of the file from discord, in this case we cannot.
            // We can get the hash from PresenceUpdateEvent.getNewAvatar() however that invalidates the consistency
            //  of just checking the latest user information from within cache.
            String userAvatarUrl = event.getUser().map(User::getAvatarUrl).block();
            Optional<ArchivedFile> aFile = ArchivedFile.getByUrl(userAvatarUrl);

            // We have the URL of this file in the DB
            if (aFile.isPresent()) {
                // If the MD5 doesn't match our last known MD5 for the users avatar then simply update the MD5
                if (!aFile.get().getMD5().equals(archivedUser.get().latest.avatarMD5)) {
                    newEntry.avatarMD5 = archivedUser.get().latest.avatarMD5;
                    archivedUser.get().latest.avatarMD5 = aFile.get().getMD5();
                    newEntry.avatarName = archivedUser.get().latest.avatarName;
                    try {
                        archivedUser.get().latest.avatarName = Paths.get(new URL(userAvatarUrl)
                            .getPath()).getFileName().toString();
                    } catch (MalformedURLException murle) {
                        archivedUser.get().latest.avatarName = "unknown";
                    }

                    changed.set(true);
                }
            } else { // We do not have the URL in the DB, we may or may not have the file entirely, need to check
                // This will download the file and add the URL to the DB for it
                String md5 = processUrl(userAvatarUrl);

                // Ensure we got the file, not ideal to completely pass on failing a download, but the next
                //  presence update will call this logic again.
                if (md5 != null) {
                    // Avatar MD5 mismatch, new avatar
                    if (!md5.equals(archivedUser.get().latest.avatarMD5)) {
                        newEntry.avatarMD5 = archivedUser.get().latest.avatarMD5;
                        archivedUser.get().latest.avatarMD5 = md5;
                        newEntry.avatarName = archivedUser.get().latest.avatarName;
                        try {
                            archivedUser.get().latest.avatarName = Paths.get(new URL(userAvatarUrl)
                                    .getPath()).getFileName().toString();
                        } catch (MalformedURLException murle) {
                            archivedUser.get().latest.avatarName = "unknown";
                        }

                        changed.set(true);
                    }
                }
            }

            // Create the new entry if the user has updated their profile.
            if (changed.get()) {
                newEntry.createEntryNow();
                archivedUser.get().latest.updateEntryNow();
            }
        } else { // No latest entry available, create it.
            return event.getUser()
                .map(ArchivedUserFactory::createNewArchivedUser)
                .map(ArchivedUserLatest::createEntryNow)
                .then();
        }

        return Mono.empty();
    }

    // TODO: This is a 1:1 duplicate method as in ArchivedMessageFactory, the logic should be extracted into
    //  an importable class (like ArchivedFile) or even better, the ArchivedFile system can be made into a
    //  standalone library
    private static String processUrl(String url) {
        // Check for if we've already saved this URL
        Optional<ArchivedFile> aFile = ArchivedFile.getByUrl(url);
        if (!aFile.isPresent()) {
            // Link isn't present, download file and compare against known MD5s
            try {
                // Get the URL data if it is of a "media" type (image/audio/video)
                ByteArrayOutputStream baos = FileManager.downloadFile(url);
                if (baos != null) {
                    // Generate the MD5 and check database
                    byte[] data = baos.toByteArray();
                    String md5 = DigestUtils.md5Hex(data);

                    if (!ArchivedFile.md5Exists(md5)) {
                        // File doesn't exist in sql, add it
                        String fileName = Paths.get(new URL(url).getPath()).getFileName().toString();
                        String fileExt = "unknown";
                        int firstDotLoc = fileName.indexOf(".");
                        if (firstDotLoc > 0) {
                            fileExt = fileName.substring(firstDotLoc + 1);
                            fileName = fileName.substring(0, firstDotLoc);
                        }

                        // Create the file and the URL in SQL, we already know that neither exist
                        List<String> urls = new ArrayList<>();
                        urls.add(url);
                        new ArchivedFile(md5, fileName, fileExt, urls, data).createNow();
                    } else {
                        // The file exists, but this is a new link, we have the MD5 now
                        aFile = ArchivedFile.getByMD5(md5);
                        if (aFile.isPresent()) {
                            aFile.get().addUrl(url);
                            aFile.get().updateUrlsNow();
                        }
                    }

                    // File was a media file and was handled properly
                    return md5;
                }
            } catch (IOException ioe) {
                logger.debug(ioe.getClass().getCanonicalName() +
                        ": " + ioe.getMessage() +
                        " - Failed to download file from: " + url);
            }
        } else {
            // We already downloaded this url, return the MD5 of the file
            return aFile.get().getMD5();
        }

        // File wasn't a media file, or there was an IOException
        return null;
    }

    /**
     * Called when no previous data exists for a user.
     * @param user the {@link User} to create an entry for in SQL
     * @return a new ArchivedUserLatest based on the provided user
     */
    private static ArchivedUserLatest createNewArchivedUser(User user) {
        String userName = user.getUsername();
        String userDisc = user.getDiscriminator();
        String avatarMD5 = null;
        String avatarName = null;

        try {
            if (!user.getDefaultAvatarUrl().equals(user.getAvatarUrl())) {
                ByteArrayOutputStream stream = FileManager.downloadFile(user.getAvatarUrl());
                if (stream != null) {
                    byte[] avatarData = stream.toByteArray();
                    avatarMD5 = DigestUtils.md5Hex(avatarData);

                    avatarName = Paths.get(new URL(user.getAvatarUrl()).getPath()).getFileName().toString();;
                }
            }
        } catch (IOException ioe) {
            new ThrowableReport(ioe, "Error encountered while trying to download user avatar!").reportException();
        }

        return new ArchivedUserLatest(user.getId().asLong(), userName, userDisc, avatarMD5, avatarName);
    }
}
