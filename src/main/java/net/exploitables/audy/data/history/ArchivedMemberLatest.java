package net.exploitables.audy.data.history;

import discord4j.core.object.entity.Member;
import net.exploitables.audy.AudyDatabase;
import org.jdbi.v3.core.mapper.reflect.ConstructorMapper;

import java.beans.ConstructorProperties;
import java.time.Instant;
import java.util.Optional;

/**
 * A Data Class representing the table tbl_member_history_latest.
 * Reminder: A member is a user within a guild.
 */
public class ArchivedMemberLatest {
    /** Never null: The Discord Snowflake ID of the user this data belongs to. */
    final long userId;
    /** Never null: The Discord Snowflake ID of the guild this data belongs to. */
    final long guildId;
    /** Never null: The timestamp of when this data was last updated. */
    long timestamp;
    /** Never null: The latest known nickname of the member.
     *   If the nickname was removed then this is an empty string.
     *  Sometimes null: When the subclass for history has no new data for it's entry. */
    String nickname;

    /**
     * Used when creating data for a member with no previous data.
     * @param member the member to create an instance for
     */
    ArchivedMemberLatest(Member member) {
        this.userId = member.getId().asLong();
        this.guildId = member.getGuildId().asLong();
        this.timestamp = Instant.now().toEpochMilli();
        this.nickname = member.getNickname().orElse("");
    }

    /**
     * Create a new instance with data retrieved from SQL.
     * @param userId the Snowflake ID of the user
     * @param guildId the Snowflake ID of the guild
     * @param timestamp the last time this data was updated
     * @param nickname the nickname the member currently has
     */
    @ConstructorProperties({"user_id", "guild_id", "timestamp", "nickname"})
    public ArchivedMemberLatest(long userId, long guildId, long timestamp, String nickname) {
        this.userId = userId;
        this.guildId = guildId;
        this.timestamp = timestamp;
        this.nickname = nickname;
    }

    /**
     * Fetch the row for the latest member nickname from SQL.
     * @param userId the Snowflake ID of the user
     * @param guildId the Snowflake ID of the guild
     * @return a newly created {@link ArchivedMemberLatest} instance if a row is present, empty other wise
     */
    public static Optional<ArchivedMemberLatest> get(long userId, long guildId) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
           handle.registerRowMapper(ConstructorMapper.factory(ArchivedMemberLatest.class));
           return handle.createQuery("SELECT * FROM tbl_member_history_latest WHERE" +
               " user_id = :user_id AND" +
               " guild_id = :guild_id;")
               .bind("user_id", userId)
               .bind("guild_id", guildId)
               .mapTo(ArchivedMemberLatest.class)
               .findOne();
        });
    }

    /**
     * Fetch the row for the latest member nickname from SQL.
     * @param member the D4J member to fetch data for
     * @return a newly created {@link ArchivedMemberLatest} instance if a row is present, empty other wise
     */
    public static Optional<ArchivedMemberLatest> get(Member member) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedMemberLatest.class));
            return handle.createQuery("SELECT * FROM tbl_member_history_latest WHERE" +
                " user_id = :user_id AND" +
                " guild_id = :guild_id;")
                .bind("user_id", member.getId().asLong())
                .bind("guild_id", member.getGuildId().asLong())
                .mapTo(ArchivedMemberLatest.class)
                .findOne();
        });
    }

    /**
     * Create a new row in SQL representing this data
     * @return this instance
     */
    ArchivedMemberLatest createNow() {
        AudyDatabase.getJdbi().useHandle(handle -> {
            handle.createUpdate("INSERT INTO tbl_member_history_latest (" +
                " user_id," +
                " guild_id," +
                " timestamp," +
                " nickname" +
                ") VALUES (" +
                " :user_id," +
                " :guild_id," +
                " :timestamp," +
                " :nickname" +
                ");")
                .bind("user_id", this.userId)
                .bind("guild_id", this.guildId)
                .bind("timestamp", this.timestamp)
                .bind("nickname", this.nickname)
                .execute();
        });

        return this;
    }

    /**
     * Update this object in SQL immediately with a new timestamp and nickname
     * @return this instance
     */
    ArchivedMemberLatest updateNow() {
        AudyDatabase.getJdbi().useHandle(handle -> {
            handle.createUpdate("UPDATE tbl_member_history_latest SET" +
                " timestamp = :timestamp," +
                " nickname = :nickname" +
                " WHERE" +
                " user_id = :user_id AND" +
                " guild_id = :guild_id" +
                ";")
                .bind("user_id", this.userId)
                .bind("guild_id", this.guildId)
                .bind("timestamp", this.timestamp)
                .bind("nickname", this.nickname)
                .execute();
        });

        return this;
    }

    public long             getUserId()     { return userId; }
    public long             getGuildId()    { return guildId; }
    public long             getTimestamp()  { return timestamp; }
    public Optional<String> getNickname()   { return Optional.ofNullable(nickname); }
}
