/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.data.history;

import net.exploitables.audy.AudyDatabase;
import org.jdbi.v3.core.mapper.reflect.ConstructorMapper;

import java.beans.ConstructorProperties;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

public class ArchivedMessageContent {
    /** Never null: UUID of the row in the table, since there can be multiple rows with the same message id */
    private final String uuid;
    /** Never null: ID of the Message this content came from */
    private final long messageId;
    /** Never null: Content of the message at the given timestamp below */
    private final String content;
    /** Never null: 0 if this content is the content the Message was originally posted with.
     * This is so that it is easily discernible what rows in SQL correspond to the original contents.
     * If the content is from when a Message is edited then the value will be Millis since the Unix Epoch. */
    private final Long timestamp;
    /** Never null: A list of MD5 hashes of files linked to by this message content. empty when there
     * are no links or no links that a file could be downloaded from.*/
    private final Set<String> linkedFileHashes;

    /** Create a new Instance of this class with field data pre-generated from SQL or {@link ArchivedMessageFactory}*/
    @ConstructorProperties({"pk_uuid", "message_id", "content", "timestamp", "linked_files"})
    public ArchivedMessageContent(String uuid, Long messageId, String content, Long timestamp, Set<String> linkedFiles) {
        // JDBI does not expose a UUID type so we must use a String type.
        // Could cast to UUID type, but want to keep consistency in that SQL representative objects
        //  use the same types as stored in SQL
        this.uuid = uuid;
        this.messageId = messageId;
        this.content = content;
        this.timestamp = timestamp;
        this.linkedFileHashes = linkedFiles;
    }

    /**
     * Create this object in SQL
     * @return this instance
     */
    ArchivedMessageContent createNow() {
        AudyDatabase.getJdbi().useHandle(handle -> {
            handle.registerArrayType(String.class, "varchar");
//            handle.registerArrayType(HashSet.class, "varchar");
            handle.createUpdate("INSERT INTO tbl_message_contents (" +
                " pk_uuid," +
                " message_id," +
                " content," +
                " timestamp," +
                " linked_files" +
                " ) VALUES (" +
                " :pk_uuid," +
                " :message_id," +
                " :content," +
                " :timestamp," +
                " :linked_files" +
                ");")
                .bind("pk_uuid", UUID.fromString(this.uuid))
                .bind("message_id", this.messageId)
                .bind("content", this.content)
                .bind("timestamp", this.timestamp)
                .bindArray("linked_files", String.class, this.linkedFileHashes.toArray())
                .execute();
        });

        return this;
    }

    /**
     * Get a single row by it's UUID
     * @param uuid the uuid for the row
     * @return a newly created {@link ArchivedMessageContent} representing the row if it exists in SQL
     */
    public static Optional<ArchivedMessageContent> getByUUID(String uuid) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedMessageContent.class));
            return handle.createQuery("SELECT * FROM tbl_message_contents WHERE" +
                " pk_uuid = :pk_uuid;")
                .bind("pk_uuid", uuid)
                .mapTo(ArchivedMessageContent.class)
                .findOne();
        });
    }

    /**
     * Get all rows for a provided message id.
     * @param messageId the message id
     * @return a list newly created {@link ArchivedMessageContent} where each entry represents a row in SQL.
     *      The list may be empty, but will be sorted with oldest entries first (ascending order).
     */
    public static List<ArchivedMessageContent> getByMessageId(long messageId) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedMessageContent.class));
            return handle.createQuery("SELECT * FROM tbl_message_contents WHERE" +
                " message_id = :message_id" +
                " ORDER BY timestamp ASC;")
                .bind("message_id", messageId)
                .mapTo(ArchivedMessageContent.class)
                .list();
        });
    }

    public String                   getUuid()               { return uuid; }
    public long                     getMessageId()          { return messageId; }
    public String                   getContent()            { return content; }
    public long                     getTimestamp()          { return timestamp; }
    public Set<String>              getLinkedFileHashes()   { return linkedFileHashes; }
}
