/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.data.history;

import net.exploitables.audy.AudyDatabase;
import net.exploitables.audy.utilities.FileManager;
import org.apache.commons.codec.digest.DigestUtils;
import org.jdbi.v3.core.mapper.reflect.ConstructorMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.beans.ConstructorProperties;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class ArchivedFile {
    private static final Logger logger = LoggerFactory.getLogger(ArchivedFile.class);

    /** Never null: An MD5 checksum of the file. */
    private String md5;
    /** Never null: Name of the file. Either as provided or "unknown". */
    private String name;
    /** Never null: Extension of the file. Either as provided, parsed from Mime types, or "unknown". */
    private String extension;
    /** Never null: A list of all known URLs for a file */
    private List<String> urls;
    /** Never null: Complete file data as a Byte Array. */
    private byte[] data;

    /** Create a new Instance of this class with field data pre-generated from SQL or {@link ArchivedMessageFactory} */
    @ConstructorProperties({"pk_md5", "name", "extension", "urls", "data_bytes"})
    public ArchivedFile(String md5, String name, String extension, List<String> urls, byte[] data) {
        this.md5 = md5;
        this.name = name;
        this.extension = extension;
        this.urls = urls;
        this.data = data;
    }

    /**
     * Evaluate a URL and potentially its contents to add them into sql.
     *
     * There are a few states that can exist here:
     *      tbl_file
     *      New File +      New URL (no entry)      : Row created in SQL
     *      New File +      New URL (existing entry): Not possible by design
     *      New File + Existing URL (existing entry): Not possible by Design
     * Existing File +      New URL (no entry)      : URL is added to SQL
     * Existing File +      New URL (existing entry): URL is added to SQL
     * Existing File + Existing URL (existing entry): No action taken, file is not checked due to design
     *
     * @param url the URL of the file we want to save to sql
     * @return the MD5 checksum of the linked file if it is valid for storage in sql, and is stored in sql, null otherwise
     */
    public static String getMD5FromUrl(String url) {
        logger.debug("Checking URL: " + url);
        // Check for if we've already saved this URL
        Optional<ArchivedFile> aFile = ArchivedFile.getByUrl(url);
        if (!aFile.isPresent()) {
            logger.debug("URL is not present in DB, downloading. URL: " + url);
            // Link isn't present, download file and compare against known MD5s
            try {
                // Get the URL data if it is of a "media" type (image/audio/video)
                ByteArrayOutputStream baos = FileManager.downloadFile(url);
                if (baos != null) {
                    // Generate the MD5 and check database
                    byte[] data = baos.toByteArray();
                    String md5 = DigestUtils.md5Hex(data);
                    logger.debug("URL '" + url + "' MD5 is: " + md5);

                    if (!ArchivedFile.md5Exists(md5)) {
                        logger.debug("File doesn't exist, adding now. MD5: " + md5);
                        // File doesn't exist in sql, add it
                        String fileName = Paths.get(new URL(url).getPath()).getFileName().toString();
                        String fileExt = "unknown";
                        int firstDotLoc = fileName.indexOf(".");
                        if (firstDotLoc > 0) {
                            fileExt = fileName.substring(firstDotLoc + 1);
                            fileName = fileName.substring(0, firstDotLoc);
                        }

                        // Create the file and the URL in SQL, we already know that neither exist
                        List<String> urls = new ArrayList<>();
                        urls.add(url);
                        new ArchivedFile(md5, fileName, fileExt, urls, data).createNow();
                    } else {
                        logger.debug("File exists, adding URL for MD5: " + md5);
                        // The file exists, but this is a new link, we have the MD5 now
                        aFile = ArchivedFile.getByMD5(md5);
                        if (aFile.isPresent()) {
                            aFile.get().addUrl(url);
                            aFile.get().updateUrlsNow();
                        }
                    }

                    // File was a media file and was handled properly
                    return md5;
                } else {
                    logger.debug("URL returned no entity: " + url);
                }
            } catch (IOException ioe) {
                logger.debug(ioe.getClass().getCanonicalName() +
                        ": " + ioe.getMessage() +
                        " - Failed to download file from: " + url);
            }
        } else {
            logger.debug("URL already in DB: " + url);
            // We already downloaded this url, return the MD5 of the file
            return aFile.get().getMD5();
        }

        // File wasn't a media file, or there was an IOException
        return null;
    }

    /**
     * @param md5 the MD5 checksum of the file to check for
     * @return true if a file with the given MD5 exists in the database, false otherwise.
     */
    public static boolean md5Exists(String md5) {
        return AudyDatabase.getJdbi().withHandle(handle ->
            handle.createQuery("SELECT pk_md5 FROM tbl_files WHERE" +
                " pk_md5 = :pk_md5;")
                .bind("pk_md5", md5)
                .mapTo(String.class)
                .findOne()
                .isPresent());
    }

    /**
     * @param url the url of an archived file to search for
     * @return true if a file with the given MD5 exists in the database, false otherwise.
     */
    public static boolean urlExists(String url) {
        return AudyDatabase.getJdbi().withHandle(handle ->
            handle.createQuery("SELECT urls FROM tbl_files WHERE" +
                " ANY(urls) = :urls;")
                .bind("urls", url)
                .mapTo(String[].class)
                .findOne()
                .isPresent());
    }

    /**
     * Get an Archived File from SQL by it's MD5
     * @param md5 the MD5 of the file
     * @return a present optional of a representative {@link ArchivedFile} if available, empty otherwise
     */
    public static Optional<ArchivedFile> getByMD5(String md5) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedFile.class));
            return handle.createQuery("SELECT * FROM tbl_files WHERE" +
                " pk_md5 = :pk_md5;")
                .bind("pk_md5", md5)
                .mapTo(ArchivedFile.class)
                .findOne();
        });
    }

    /**
     * @param url the url of an archived file to search for
     * @return a present optional if a representative (@link ArciveFileLink} if available, empty otherwise
     */
    public static Optional<ArchivedFile> getByUrl(String url) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedFile.class));
            return handle.createQuery("SELECT * FROM tbl_files WHERE" +
                " :urls = ANY(urls);")
                .bind("urls", url)
                .mapTo(ArchivedFile.class)
                .findOne();
        });
    }

    /**
     * Add a Url to the set of known Urls and save this instance to sql
     * @param url new Url to add
     * @return this instance modified and saved
     */
    ArchivedFile addUrl(String url) {
        this.urls.add(url);
        return this.updateUrlsNow();
    }

    /** Create a new row in SQL representing this data
     * @return this instance
     * */
    ArchivedFile createNow() {
        AudyDatabase.getJdbi().useHandle(handle -> {
            handle.registerArrayType(String.class, "varchar");
            handle.createUpdate("INSERT INTO tbl_files (" +
                " pk_md5," +
                " name," +
                " extension," +
                " urls," +
                " data_bytes" +
                " ) VALUES (" +
                " :md5," +
                " :name," +
                " :extension," +
                " :urls," +
                " :data" +
                ");")
                .bind("md5", this.md5)
                .bind("name", this.name)
                .bind("extension", this.extension)
                .bindArray("urls", String.class, this.urls)
                .bind("data", this.data)
                .execute();
        });

        return this;
    }

    /**
     * Update this object in SQL immediately with a new array of Urls
     * @return this instance
     */
    ArchivedFile updateUrlsNow() {
        AudyDatabase.getJdbi().useHandle(handle -> {
            handle.registerArrayType(String.class, "varchar");
            handle.createUpdate("UPDATE tbl_files SET" +
                " urls = :urls" +
                " WHERE" +
                " pk_md5 = :md5" +
                ";")
                .bind("md5", this.md5)
                .bindArray("urls", String.class, this.urls)
                .execute();
        });

        return this;
    }

    public String getMD5()          { return md5; }
    public String getFullName()     { return name + "." + extension; }
    public String getFileName()     { return name; }
    public String getExtension()    { return extension; }
    public byte[] getData()         { return data; }
}
