/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.data.history;

import net.exploitables.audy.AudyDatabase;
import org.jdbi.v3.core.mapper.reflect.ConstructorMapper;

import java.beans.ConstructorProperties;
import java.util.List;
import java.util.Optional;

public class ArchivedFile {
    /** Never null: An MD5 checksum of the file. */
    private String md5;
    /** Never null: Name of the file. Either as provided or "unknown". */
    private String name;
    /** Never null: Extension of the file. Either as provided, parsed from Mime types, or "unknown". */
    private String extension;
    /** Never null: A list of all known URLs for a file */
    private List<String> urls;
    /** Never null: Complete file data as a Byte Array. */
    private byte[] data;

    /** Create a new Instance of this class with field data pre-generated from SQL or {@link ArchivedMessageFactory} */
    @ConstructorProperties({"pk_md5", "name", "extension", "urls", "data_bytes"})
    public ArchivedFile(String md5, String name, String extension, List<String> urls, byte[] data) {
        this.md5 = md5;
        this.name = name;
        this.extension = extension;
        this.urls = urls;
        this.data = data;
    }

    /**
     * @param md5 the MD5 checksum of the file to check for
     * @return true if a file with the given MD5 exists in the database, false otherwise.
     */
    public static boolean md5Exists(String md5) {
        return AudyDatabase.getJdbi().withHandle(handle ->
            handle.createQuery("SELECT pk_md5 FROM tbl_files WHERE" +
                " pk_md5 = :pk_md5;")
                .bind("pk_md5", md5)
                .mapTo(String.class)
                .findOne()
                .isPresent());
    }

    /**
     * @param url the url of an archived file to search for
     * @return true if a file with the given MD5 exists in the database, false otherwise.
     */
    public static boolean urlExists(String url) {
        return AudyDatabase.getJdbi().withHandle(handle ->
            handle.createQuery("SELECT urls FROM tbl_files WHERE" +
                " ANY(urls) = :urls;")
                .bind("urls", url)
                .mapTo(String[].class)
                .findOne()
                .isPresent());
    }

    /**
     * Get an Archived File from SQL by it's MD5
     * @param md5 the MD5 of the file
     * @return a present optional of a representative {@link ArchivedFile} if available, empty otherwise
     */
    public static Optional<ArchivedFile> getByMD5(String md5) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedFile.class));
            return handle.createQuery("SELECT * FROM tbl_files WHERE" +
                " pk_md5 = :pk_md5;")
                .bind("pk_md5", md5)
                .mapTo(ArchivedFile.class)
                .findOne();
        });
    }

    /**
     * @param url the url of an archived file to search for
     * @return a present optional if a representative (@link ArciveFileLink} if available, empty otherwise
     */
    public static Optional<ArchivedFile> getByUrl(String url) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedFile.class));
            return handle.createQuery("SELECT * FROM tbl_files WHERE" +
                " :urls = ANY(urls);")
                .bind("urls", url)
                .mapTo(ArchivedFile.class)
                .findOne();
        });
    }

    /**
     * Add a Url to the set of known Urls and save this instance to sql
     * @param url new Url to add
     * @return this instance modified and saved
     */
    ArchivedFile addUrl(String url) {
        this.urls.add(url);
        return this.updateUrlsNow();
    }

    /** Create a new row in SQL representing this data
     * @return this instance
     * */
    ArchivedFile createNow() {
        AudyDatabase.getJdbi().useHandle(handle -> {
            handle.registerArrayType(String.class, "varchar");
            handle.createUpdate("INSERT INTO tbl_files (" +
                " pk_md5," +
                " name," +
                " extension," +
                " urls," +
                " data_bytes" +
                " ) VALUES (" +
                " :md5," +
                " :name," +
                " :extension," +
                " :urls," +
                " :data" +
                ");")
                .bind("md5", this.md5)
                .bind("name", this.name)
                .bind("extension", this.extension)
                .bindArray("urls", String.class, this.urls)
                .bind("data", this.data)
                .execute();
        });

        return this;
    }

    /**
     * Update this object in SQL immediately with a new array of Urls
     * @return this instance
     */
    ArchivedFile updateUrlsNow() {
        AudyDatabase.getJdbi().useHandle(handle -> {
            handle.registerArrayType(String.class, "varchar");
            handle.createUpdate("UPDATE tbl_files SET" +
                " urls = :urls" +
                " WHERE" +
                " pk_md5 = :md5" +
                ";")
                .bind("md5", this.md5)
                .bindArray("urls", String.class, this.urls)
                .execute();
        });

        return this;
    }

    public String getMD5()          { return md5; }
    public String getFullName()     { return name + "." + extension; }
    public String getFileName()     { return name; }
    public String getExtension()    { return extension; }
    public byte[] getData()         { return data; }
}
