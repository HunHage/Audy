package net.exploitables.audy.data.history;

import discord4j.core.object.entity.Attachment;
import net.exploitables.audy.AudyDatabase;
import org.jdbi.v3.core.mapper.reflect.ConstructorMapper;

import java.beans.ConstructorProperties;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Object representing a Discord Message Attachment stored in SQL
 */
public class ArchivedMessageAttachment{
    /** Never null: The UUID for this attachment's row in SQL */
    private final String uuid;
    /** Never null: The MD5 checksum of the attachment as entered into tbl_file in sql */
    private final String md5;
    /** Never null: The ID of the Message that this Attachment was uploaded with*/
    private final long messageId;
    /** Never null: If the Attachment is marked as a spoiler, if true the full filename will have
     *  {@link discord4j.core.object.entity.Attachment#SPOILER_PREFIX} prepended to it. */
    private final boolean spoiler;
    /** Never null: The filename provided with the attachment. */
    private final String fileName;
    /** Never null: The file extension provided with the attachment.
     * If not provided or unable to be parsed will be `unknown` */
    private final String fileExtension;


    /**
     * Create a new instance of this class, should only be created by {@link ArchivedMessageFactory}
     * and after creation
     *
     * @param messageId ID of the Message this Attachment was uploaded with
     * @param spoiler If this Attachment is marked as a spoiler
     * See {@link ArchivedFile}
     */
    @ConstructorProperties({"pk_uuid", "md5", "message_id", "spoiler", "file_name", "file_extension"})
    public ArchivedMessageAttachment(String uuid, String md5, Long messageId, boolean spoiler, String fileName, String fileExtension) {
        this.uuid = uuid;
        this.md5 = md5;
        this.messageId = messageId;
        this.spoiler = spoiler;
        this.fileName = fileName;
        this.fileExtension = fileExtension;
    }

    /**
     * Create a row for this data in SQL
     * @return this instance
     */
    ArchivedMessageAttachment createNow() {
        AudyDatabase.getJdbi().useHandle(handle -> {
            handle.createUpdate("INSERT INTO tbl_message_attachments (" +
                " pk_uuid," +
                " md5," +
                " message_id," +
                " spoiler," +
                " file_name," +
                " file_extension" +
                " ) VALUES (" +
                " :pk_uuid," +
                " :md5," +
                " :message_id," +
                " :spoiler," +
                " :file_name," +
                " :file_extension" +
                ");")
                .bind("pk_uuid", UUID.fromString(this.uuid))
                .bind("md5", this.md5)
                .bind("message_id", this.messageId)
                .bind("spoiler", this.spoiler)
                .bind("file_name", this.fileName)
                .bind("file_extension", this.fileExtension)
                .execute();
        });

        return this;
    }

    /**
     * Get a row in SQL by it's UUID.
     * @param uuid the UUID for the attachment in SQL
     * @return a newly created ArchivedMessageAttachment if a row exists for the uuid
     */
    public static Optional<ArchivedMessageAttachment> getAttachmentByUUID(String uuid) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedMessageAttachment.class));
            return handle.createQuery("SELECT * FROM tbl_message_attachments WHERE" +
                " pk_uuid = :pk_uuid;")
                .bind("pk_uuid", uuid)
                .mapTo(ArchivedMessageAttachment.class)
                .findOne();
        });
    }

    /**
     * Get all rows in SQL that have the provided message id.
     * @param messageId the message id to get attachments for.
     * @return a list of 0-n attachments from sql.
     */
    public static List<ArchivedMessageAttachment> getAttachmentsByMessageId(long messageId) {
        return AudyDatabase.getJdbi().withHandle(handle -> {
            handle.registerRowMapper(ConstructorMapper.factory(ArchivedMessageAttachment.class));
            return handle.createQuery("SELECT * FROM tbl_message_attachments WHERE" +
                " message_id = :message_id;")
                .bind("message_id", messageId)
                .mapTo(ArchivedMessageAttachment.class)
                .list();
        });
    }

    public String   getUuid()           { return uuid; }
    public String   getMD5()            { return md5; }
    public long     getMessageId()      { return messageId; }
    public boolean  isSpoiler()         { return spoiler; }
    /** The file name as discord modifies it to be when the file is a spoiler */
    public String   getFileName()       { return Attachment.SPOILER_PREFIX + fileName; }
    public String   getRawFileName()    { return fileName; }
    public String   getFileExtension()  { return fileExtension; }
}
