package net.exploitables.audy.data.history;

import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.event.domain.message.MessageUpdateEvent;
import discord4j.core.object.entity.Attachment;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.channel.GuildChannel;
import net.exploitables.audy.utilities.FileManager;
import org.apache.commons.codec.digest.DigestUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Paths;
import java.util.*;
import java.util.regex.Matcher;

/**
 * Factory class that handles creation, addition, and modification of objects representing stored SQL data
 */
public class ArchivedMessageFactory {
    private static final Logger logger = LoggerFactory.getLogger(ArchivedMessageFactory.class);

    /**
     * Receive a new message and create it in SQL along with it's content and attachments if present.
     *
     * @param event the new event containing information on the Message
     * @return Mono of the created ArchivedMessage
     */
    public static Mono<ArchivedMessage> receiveMessageCreateEvent(MessageCreateEvent event) {
        // Only log messages from guilds.
        Message message = event.getMessage();
        if (message.getChannel().ofType(GuildChannel.class).block() == null) return Mono.empty();

        // Create the ArchivedMessage and set the source.
        ArchivedMessage newMessage = createArchivedMessage(message);
        newMessage.lastSource = ArchivedMessageSource.MCE;
        // We've collected data on the Message, Content Links, and Message Attachments, we're good to go.
        // This call cascades into added ArchivedMessageContent and ArchivedMessageAttachment objects.
        newMessage.createNow();

//        // debug time, get the message back and reply with it's content and images
//        ArchivedMessage test = ArchivedMessage.getById(message.getId().asLong()).get();
//        Consumer<MessageCreateSpec> spec = (msg) -> {
//          msg.setContent(test.getContents().get(0).getContent());
//          for (String md5 : test.getContents().get(0).getLinkedFileHashes()) {
//              ArchivedFile aFile = ArchivedFile.getByMD5(md5).get();
//              msg.addFile(aFile.getFullName(), new ByteArrayInputStream(aFile.getData()));
//          }
//          for (ArchivedMessageAttachment attachment : test.getAttachments()) {
//              ArchivedFile aFile = ArchivedFile.getByMD5(attachment.getMD5()).get();
//              msg.addFile(attachment.getRawFileName() + "." + attachment.getFileExtension(), new ByteArrayInputStream(aFile.getData()));
//          }
//        };
//        message.getChannel().flatMap(channel -> channel.createMessage(spec)).block();

        return Mono.empty();
    }

    /**
     * Receive an updated message and save into SQL. If the message doesn't exist in SQL it will be created and flagged
     *  that the message update event was missed.
     *
     * @param event the even containing information about the edited message
     * @return an empty mono
     */
    public static Mono<Void> receiveMessageUpdateEvent(MessageUpdateEvent event) {
        // If Discord has updated this message to include an embed then there's nothing for us to process
        if (event.isContentChanged()) return Mono.empty();
        // Only handle events from guilds
        if (event.getMessage()
                .flatMap(Message::getChannel)
                .ofType(GuildChannel.class)
                .block() == null) {
            return Mono.empty();
        }

        Message newMessage = event.getMessage().block();
        Message oldMessage = event.getOld().orElse(null);
        Optional<ArchivedMessage> archivedMessage = ArchivedMessage.getById(event.getMessageId().asLong());

        if (archivedMessage.isPresent()) {
            ArchivedMessage aMessage = archivedMessage.get();
            aMessage.lastSource = ArchivedMessageSource.MUE;

            if (oldMessage != null) {
                // We don't record empty content, I think this should never happen and is always true?
                if (!oldMessage.getContent().isEmpty()) {
                    // When we get the content, the final entry is always the latest entry
                    if (!aMessage.getContents()
                            .get(aMessage.getContents().size() - 1)
                            .getContent()
                            .equals(oldMessage.getContent())) {
                        // We're missing the previous content of the message. At this point, we have an sql entry for
                        //  the message so we did not miss either a MCE **or** a MUE. So we want to mark that we missed
                        //  an update event since there can be multiple MUEs but only one MCE.

                        // It's very unlikely that we will have cached a message after missing the previous event.
                        // It may be an interest to account for that possibility, however based on some loose estimates
                        //  message edits are very uncommon (like 10% compared to MCE), and are very often close to
                        //  when the message was created or when the message was edited previously. I don't think the
                        //  chances of this edge case are high enough to warrant covering it.
                        // Sources: ~~just trust be bro~~ I counted the events over a period of months on a server
                        //  I moderated. But that is a single server sample size, and less than 100 active users.
                        aMessage.messageFlags = ArchivedMessageFlags
                            .addFlags(aMessage.messageFlags, ArchivedMessageFlags.MISSING_UPDATE);
                    }
                }
            }

            // We can now process the new message.
            // As of 2021/01/25 the only way I know a message can be edited to have empty content is if it is being
            //  deleted. We only need it present.
            if (newMessage != null) {
                // Cover the case where a message was uploaded with no content but with attachments,
                //  but then was edited to have content.
                aMessage.hasContent = true;
                // Unlike when a message is created, the required foreign keys are
                //  already present so we can create this immediately. And don't need to add it to aMessage.
                ArchivedMessageContent newContent = processMessageContent(newMessage);
                newContent.createNow();
            }

            // Attachments cannot be edited after a message is posted. We can move to updating the ArchivedMessage.
            aMessage.updateNow();

            // Debug time
            ArchivedMessage test = ArchivedMessage.getById(event.getMessageId().asLong()).get();
            test.getContents();
            test.getAttachments();
        } else {
            if (newMessage != null) {
                // No message present in sql, it must be created and flagged.
                ArchivedMessage aMessage = createArchivedMessage(newMessage);
                aMessage.lastSource = ArchivedMessageSource.MUE;
                aMessage.messageFlags = ArchivedMessageFlags.of(ArchivedMessageFlags.MISSING_CREATE);
                aMessage.createNow();

                // Debug time
                ArchivedMessage test = ArchivedMessage.getById(event.getMessageId().asLong()).get();
                test.getContents();
                test.getAttachments();
            } else {
                // The new message should almost *always* be present from my understanding, we could get the channel ID
                //  and locate the guild ID from that but this edge case seems too rare to cover.
                logger.warn("Expected newMessage to be present for MUE! Message ID: " + event.getMessageId().asString());
            }
        }

        return Mono.empty();
    }

    /**
     * Create an ArchivedMessage that will be used to create data in sql repressing the message.
     * This should only be used when no message exists for the provided one in sql.
     *
     * @param message the message to extract attachments, links, and contents into an {@link ArchivedMessage} which
     *                can be stored in SQL.
     * @return a {@link ArchivedMessage} representing the provided message. {@link ArchivedMessage#createNow()} must
     *          be called after this method to created and stored it in SQL.
     */
    private static ArchivedMessage createArchivedMessage(Message message) {
        // Create new ArchivedMessage and save to SQL (required to add contents/attachments later)
        ArchivedMessage newMessage = new ArchivedMessage(message.getId().asLong(), message.getGuildId().get().asLong());
        newMessage.channelId = message.getChannelId().asLong();
        newMessage.authorId = message.getAuthor().get().getId().asLong();

        if (!message.getContent().isEmpty()) {
            newMessage.hasContent = true;
            newMessage.addContent(processMessageContent(message));
        }

        // Done with URLs and message content, create attachments
        for (Attachment attachment : message.getAttachments()) {
            // We don't need to run this through the regex matcher as we *know* it's a pure url
            String md5 = processUrl(attachment.getUrl());
            if (md5 != null) {
                newMessage.hasAttachments = true;
                newMessage.addAttachment(processMessageAttachment(message, attachment, md5));
            } else {
                // Something happened, the file should be downloadable. Log as warning and continue.
                // This may happen if users upload a file with no extension, or if it can't be accessed.
                logger.warn("Couldn't archive message attachment!\nMessage ID: " + message.getId().asString() +
                        "\nURL: " + attachment.getUrl());
            }
        }

        return newMessage;
    }

    /**
     * Evaluate a URL and potentially it's contents to add them into sql.
     *
     * There are a few states that can exist here:
     *      tbl_file |      tbl_file_links
     *      New File +      New URL (no entry)      : Both are created in SQL
     *      New File +      New URL (existing entry): Not possible by design
     *      New File + Existing URL (existing entry): Not possible by Design
     * Existing File +      New URL (no entry)      : Warning is logged and URL is added to SQL
     * Existing File +      New URL (existing entry): URL is added to SQL
     * Existing File + Existing URL (existing entry): No action taken, file is not checked due to design
     *
     * @param url the URL of the file we want to save to sql
     * @return the MD5 checksum of the linked file if it is valid for storage in sql, and is stored in sql, null otherwise
     */
    private static String processUrl(String url) {
        // Check for if we've already saved this URL
        Optional<ArchivedFileLink> afLink = ArchivedFileLink.getByUrl(url);
        if (!afLink.isPresent()) {
            // Link isn't present, download file and compare against known MD5s
            try {
                // Get the URL data if it is of a "media" type (image/audio/video)
                ByteArrayOutputStream baos = FileManager.downloadFile(url);
                if (baos != null) {
                    // Generate the MD5 and check database
                    byte[] data = baos.toByteArray();
                    String md5 = DigestUtils.md5Hex(data);

                    if (!ArchivedFile.md5Exists(md5)) {
                        // File doesn't exist in sql, add it
                        String fileName = Paths.get(new URL(url).getPath()).getFileName().toString();
                        String fileExt = "unknown";
                        int firstDotLoc = fileName.indexOf(".");
                        if (firstDotLoc > 0) {
                            fileExt = fileName.substring(firstDotLoc + 1);
                            fileName = fileName.substring(0, firstDotLoc);
                        }

                        // Create the file and the URL in SQL, we already know that neither exist
                        new ArchivedFile(md5, fileName, fileExt, data).createNow();
                        List<String> urls = new ArrayList<>();
                        urls.add(url);
                        // Since this MD5 doesn't exist, we can't have any links for it, it's safe to add the link
                        new ArchivedFileLink(md5, urls).createNow();
                    } else {
                        // The file exists, but this is a new link, we have the MD5 now
                        afLink = ArchivedFileLink.getByMD5(md5);
                        if (afLink.isPresent()) {
                            afLink.get().addUrl(url);
                        } else {
                            // This shouldn't happen, as this system is designed to only get files from
                            //  online sources (even attachments will have links). But if this does it can
                            //  at the least concern be appropriate (file added offline) or most concerning
                            //  for some reason the link wasn't recorded.
                            logger.warn("No ArchivedFileLink found in SQL when expected!\nmd5:"  + md5 + "\nURL: " + url);
                            List<String> urls = new ArrayList<>();
                            urls.add(url);
                            new ArchivedFileLink(md5, urls).createNow();
                        }
                    }

                    // File was a media file and was handled properly
                    return md5;
                }
            } catch (IOException ioe) {
                logger.debug(ioe.getClass().getCanonicalName() +
                    ": " + ioe.getMessage() +
                    " - Failed to download file from: " + url);
            }
        } else {
            // We already downloaded this url, return the MD5 of the file
            return afLink.get().getMD5();
        }

        // File wasn't a media file, or there was an IOException
        return null;
    }

    /**
     * Scan the content of a message for URLs which have valid downloadable files
     *
     * @param message the {@link Message} with the content to analyze
     * @return a newly created {@link ArchivedMessageContent} for the current message content
     */
    private static ArchivedMessageContent processMessageContent(Message message) {
        // First we need to replace all white space with a single space, remove extra spaces, then split by spaces
        // This also turns common characters used to prevent embedding and spoilering text into spaces
        // One serious caveat here, is that the | key can be in URLs from my understanding, but I don't think it's
        //  common enough for how often || is used for spoilers
        String[] terms = message.getContent().replaceAll("[\\s<>{}\\[\\]()|]+", " ").trim().split(" ");
        Set<String> validMD5s = new HashSet<>();

        for (String term : terms) {
            Matcher matcher = FileManager.urlRegex.matcher(term);
            if (matcher.matches()) {
                // Process this URL to add it and it's file to the database
                // We get group 2 as it is the full URL with no side tokens for discord spoiler/no embed
                String md5 = processUrl(matcher.group(2));
                if (md5 != null) {
                    validMD5s.add(md5);
                }
            }
        }

        // The ID is set to zero as a "shortcut" for getting the *original message contents*
        long timestamp = (message.getEditedTimestamp().isPresent())
                ? message.getEditedTimestamp().get().toEpochMilli() : 0L;
        // Create Message Contents, don't create contents as they must be created *after* the message
        // So the calling method must create this data
        return new ArchivedMessageContent(
            UUID.randomUUID().toString(),
            message.getId().asLong(),
            message.getContent(),
            timestamp,
            validMD5s);
    }

    /**
     * Create an ArchivedMessageAttachment representing the specified attachment.
     *
     * @param message the {@link Message} the {@link Attachment} belongs to.
     *                There is Attachment#getId() however the D4J docs are vague.
     * @param attachment the {@link Attachment} to extract data from to be stored in sql
     * @return a newly created {@link ArchivedMessageAttachment} for the attackment
     */
    private static ArchivedMessageAttachment processMessageAttachment(Message message, Attachment attachment, String md5) {
        // Parse filename and extension from attachment URL, which is far simpler than general URLs
        // We get the name directly from the attachment url, as this is the only way to reasonably
        //  preserve filenames based on user upload, we don't care too much if multiple links have
        //  different file names for the same file as the links are normally not created by the user.
        // Another way to put it, is we only care about the filename if it is what the user changed it to.
        int loc = attachment.getUrl().lastIndexOf("/");
        String fileName = attachment.getUrl().substring(loc + 1);
        String fileExt = "unknown";
        // Decided to do last index of instead of first, this avoids nonsense such as `filename.png.png`
        loc = fileName.lastIndexOf(".");
        if (loc != -1) {
            fileExt = fileName.substring(loc + 1);
            fileName = fileName.substring(0, loc);
        }
        if (attachment.isSpoiler()) {
            fileName = fileName.substring(Attachment.SPOILER_PREFIX.length() + 1);
        }
        // We don't do MD5 checks as we do want to store the file name/extension.
        return new ArchivedMessageAttachment(
            UUID.randomUUID().toString(),
            md5,
            message.getId().asLong(),
            attachment.isSpoiler(),
            fileName,
            fileExt);
    }
}
