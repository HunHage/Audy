package net.exploitables.audy.data.history;

import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.object.entity.Attachment;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.channel.GuildChannel;
import discord4j.core.spec.MessageCreateSpec;
import net.exploitables.audy.utilities.FileManager;
import org.apache.commons.codec.digest.DigestUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.Consumer;
import java.util.regex.Matcher;

/**
 * Factory class that handles creation, addition, and modification of objects representing stored SQL data
 */
public class ArchivedMessageFactory {
    private static final Logger logger = LoggerFactory.getLogger(ArchivedMessageFactory.class);

    /**
     * Receive a new message and create it in SQL along with it's content and attachments if present.
     *
     * @param event the new event containing information on the Message
     * @return Mono of the created ArchivedMessage
     */
    public static Mono<ArchivedMessage> receiveMessageCreateEvent(MessageCreateEvent event) {
        // Only log messages from guilds.
        Message message = event.getMessage();
        if (message.getChannel().ofType(GuildChannel.class).block() == null) return Mono.empty();

        // Create new ArchivedMessage and save to SQL (required to add contents/attachments later)
        ArchivedMessage newMessage = new ArchivedMessage(message.getId().asLong(), event.getGuildId().get().asLong());
        newMessage.channelId = message.getChannelId().asLong();
        newMessage.authorId = event.getMember().get().getId().asLong();
        newMessage.lastSource = ArchivedMessageSource.MCE;

        if (!message.getContent().isEmpty()) {
            newMessage.hasContent = true;
            newMessage.addContent(processMessageContent(message));
        }

        // Done with URLs and message content, create attachments
        for (Attachment attachment : message.getAttachments()) {
            // We don't need to run this through the regex matcher as we *know* it's a pure url
            String md5 = processUrl(attachment.getUrl());
            if (md5 != null) {
                newMessage.hasAttachments = true;
                newMessage.addAttachment(processMessageAttachment(message, attachment, md5));
            } else {
                // Something happened, the file should be downloadable. Log as warning and continue.
                // This may happen if users upload a file with no extension, or if it can't be accessed.
                logger.warn("Couldn't archive message attachment!\nMessage ID: " + message.getId().asString() +
                    "\nURL: " + attachment.getUrl());
            }
        }

        // We've collected data on the Message, Content Links, and Message Attachments, we're good to go
        // This call cascades into added ArchivedMessageContent and ArchivedMessageAttachment objects
        newMessage.createNow();

        // debug time, get the message back and reply with it's content and images
        ArchivedMessage test = ArchivedMessage.getById(message.getId().asLong()).get();
        Consumer<MessageCreateSpec> spec = (msg) -> {
          msg.setContent(test.getContents().get(0).getContent());
          for (String md5 : test.getContents().get(0).getLinkedFileHashes()) {
              ArchivedFile aFile = ArchivedFile.getByMD5(md5).get();
              msg.addFile(aFile.getFullName(), new ByteArrayInputStream(aFile.getData()));
          }
          for (ArchivedMessageAttachment attachment : test.getAttachments()) {
              ArchivedFile aFile = ArchivedFile.getByMD5(attachment.getMD5()).get();
              msg.addFile(attachment.getRawFileName() + "." + attachment.getFileExtension(), new ByteArrayInputStream(aFile.getData()));
          }
        };

        message.getChannel().flatMap(channel -> channel.createMessage(spec)).block();

        return Mono.empty();
    }

    /**
     * Evaluate a URL and potentially it's contents to add them into sql.
     *
     * There are a few states that can exist here:
     *      tbl_file |      tbl_file_links
     *      New File +      New URL (no entry)      : Both are created in SQL
     *      New File +      New URL (existing entry): Not possible by design
     *      New File + Existing URL (existing entry): Not possible by Design
     * Existing File +      New URL (no entry)      : Warning is logged and URL is added to SQL
     * Existing File +      New URL (existing entry): URL is added to SQL
     * Existing File + Existing URL (existing entry): No action taken, file is not checked due to design
     *
     * @param url the URL of the file we want to save to sql
     * @return the MD5 checksum of the linked file if it is valid for storage in sql, and is stored in sql, null otherwise
     */
    private static String processUrl(String url) {
        // Check for if we've already saved this URL
        Optional<ArchivedFileLink> afLink = ArchivedFileLink.getByUrl(url);
        if (!afLink.isPresent()) {
            // Link isn't present, download file and compare against known MD5s
            try {
                // Get the URL data if it is of a "media" type (image/audio/video)
                ByteArrayOutputStream baos = FileManager.downloadFile(url);
                if (baos != null) {
                    // Generate the MD5 and check database
                    byte[] data = baos.toByteArray();
                    String md5 = DigestUtils.md5Hex(data);

                    if (!ArchivedFile.md5Exists(md5)) {
                        // File doesn't exist in sql, add it
                        String fileName = Paths.get(new URL(url).getPath()).getFileName().toString();
                        String fileExt = "unknown";
                        int firstDotLoc = fileName.indexOf(".");
                        if (firstDotLoc > 0) {
                            fileExt = fileName.substring(firstDotLoc + 1);
                            fileName = fileName.substring(0, firstDotLoc);
                        }

                        // Create the file and the URL in SQL, we already know that neither exist
                        new ArchivedFile(md5, fileName, fileExt, data).createNow();
                        List<String> urls = new ArrayList<>();
                        urls.add(url);
                        // Since this MD5 doesn't exist, we can't have any links for it, it's safe to add the link
                        new ArchivedFileLink(md5, urls).createNow();
                    } else {
                        // The file exists, but this is a new link, we have the MD5 now
                        afLink = ArchivedFileLink.getByMD5(md5);
                        if (afLink.isPresent()) {
                            afLink.get().addUrl(url);
                        } else {
                            // This shouldn't happen, as this system is designed to only get files from
                            //  online sources (even attachments will have links). But if this does it can
                            //  at the least concern be appropriate (file added offline) or most concerning
                            //  for some reason the link wasn't recorded.
                            logger.warn("No ArchivedFileLink found in SQL when expected!\nmd5:"  + md5 + "\nURL: " + url);
                            List<String> urls = new ArrayList<>();
                            urls.add(url);
                            new ArchivedFileLink(md5, urls).createNow();
                        }
                    }

                    // File was a media file and was handled properly
                    return md5;
                }
            } catch (IOException ioe) {
                logger.debug(ioe.getClass().getCanonicalName() +
                    ": " + ioe.getMessage() +
                    " - Failed to download file from: " + url);
            }
        } else {
            // We already downloaded this url, return the MD5 of the file
            return afLink.get().getMD5();
        }

        // File wasn't a media file, or there was an IOException
        return null;
    }

    /**
     * Scan the content of a message for URLs which have valid downloadable files
     *
     * @param message the {@link Message} with the content to analyze
     * @return a newly created {@link ArchivedMessageContent} for the current message content
     */
    private static ArchivedMessageContent processMessageContent(Message message) {
        // First we need to replace all white space with a single space, remove extra spaces, then split by spaces
        // This also turns common characters used to prevent embedding and spoilering text into spaces
        // One serious caveat here, is that the | key can be in URLs from my understanding, but I don't think it's
        //  common enough for how often || is used for spoilers
        String[] terms = message.getContent().replaceAll("[\\s<>{}\\[\\]()|]+", " ").trim().split(" ");
        Set<String> validMD5s = new HashSet<>();

        for (String term : terms) {
            Matcher matcher = FileManager.urlRegex.matcher(term);
            if (matcher.matches()) {
                // Process this URL to add it and it's file to the database
                // We get group 2 as it is the full URL with no side tokens for discord spoiler/no embed
                String md5 = processUrl(matcher.group(2));
                if (md5 != null) {
                    validMD5s.add(md5);
                }
            }
        }

        // The ID is set to zero as a "shortcut" for getting the *original message contents*
        long timestamp = (message.getEditedTimestamp().isPresent())
                ? message.getEditedTimestamp().get().toEpochMilli() : 0L;
        // Create Message Contents, don't create contents as they must be created *after* the message
        // So the calling method must create this data
        return new ArchivedMessageContent(
            UUID.randomUUID().toString(),
            message.getId().asLong(),
            message.getContent(),
            timestamp,
            validMD5s);
    }

    /**
     * Create an ArchivedMessageAttachment representing the specified attachment.
     *
     * @param message the {@link Message} the {@link Attachment} belongs to.
     *                There is Attachment#getId() however the D4J docs are vague.
     * @param attachment the {@link Attachment} to extract data from to be stored in sql
     * @return a newly created {@link ArchivedMessageAttachment} for the attackment
     */
    private static ArchivedMessageAttachment processMessageAttachment(Message message, Attachment attachment, String md5) {
        // Parse filename and extension from attachment URL, which is far simpler than general URLs
        // We get the name directly from the attachment url, as this is the only way to reasonably
        //  preserve filenames based on user upload, we don't care too much if multiple links have
        //  different file names for the same file as the links are normally not created by the user.
        // Another way to put it, is we only care about the filename if it is what the user changed it to.
        int loc = attachment.getUrl().lastIndexOf("/");
        String fileName = attachment.getUrl().substring(loc + 1);
        String fileExt = "unknown";
        // Decided to do last index of instead of first, this avoids nonsense such as `filename.png.png`
        loc = fileName.lastIndexOf(".");
        if (loc != -1) {
            fileExt = fileName.substring(loc + 1);
            fileName = fileName.substring(0, loc);
        }
        if (attachment.isSpoiler()) {
            fileName = fileName.substring(Attachment.SPOILER_PREFIX.length() + 1);
        }
        // We don't do MD5 checks as we do want to store the file name/extension.
        return new ArchivedMessageAttachment(
            UUID.randomUUID().toString(),
            md5,
            message.getId().asLong(),
            attachment.isSpoiler(),
            fileName,
            fileExt);
    }
}
