package net.exploitables.audy.data.history;

import discord4j.common.util.Snowflake;
import discord4j.core.event.domain.message.MessageBulkDeleteEvent;
import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.event.domain.message.MessageDeleteEvent;
import discord4j.core.event.domain.message.MessageUpdateEvent;
import discord4j.core.object.entity.Attachment;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.channel.GuildChannel;
import discord4j.rest.util.Permission;
import net.exploitables.audy.AudyClient;
import net.exploitables.audy.AudyMain;
import net.exploitables.audy.utilities.FileManager;
import org.apache.commons.codec.digest.DigestUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.regex.Matcher;

/**
 * Factory class that handles creation, addition, and modification of objects representing stored SQL data
 */
public class ArchivedMessageFactory {
    private static final Logger logger = LoggerFactory.getLogger(ArchivedMessageFactory.class);

    /**
     * Reused logic for if an event should be retained in the database, this prevents saving old events just to
     *  delete them on the next database cleaning.
     * @param messageId the Id of the message received in the event
     * @return true if the message Id is within the retention window and the event should be archived
     */
    private static boolean retainEvent(Snowflake messageId) {
        return messageId.getTimestamp()
            .plus(Duration.ofHours(AudyMain.getConfiguration().getUserDataRetentionHours()))
            .isAfter(Instant.now());
    }

    /**
     * Receive a new message and create it in SQL along with it's content and attachments if present.
     *
     * @param event the new event containing information on the created message from discord
     * @return Mono of the created ArchivedMessage
     */
    public static Mono<ArchivedMessage> receiveMessageCreateEvent(MessageCreateEvent event) {
        // Only log messages from guilds.
        Message message = event.getMessage();
        if (message.getChannel().ofType(GuildChannel.class).block() == null) return Mono.empty();
        // We don't need to check for if this event is new enough to be saved, creates are only delivered when
        // the message is created, so the timestamp will always be effectively "now"

        // Create the ArchivedMessage and set the source.
        ArchivedMessage newMessage = createArchivedMessage(message);
        newMessage.lastSource = ArchivedMessageSource.MCE;
        // We've collected data on the Message, Content Links, and Message Attachments, we're good to go.
        // This call cascades into added ArchivedMessageContent and ArchivedMessageAttachment objects.
        newMessage.createNow();

//        // debug time, get the message back and reply with it's content and images
//        ArchivedMessage test = ArchivedMessage.getById(message.getId().asLong()).get();
//        Consumer<MessageCreateSpec> spec = (msg) -> {
//          msg.setContent(test.getContents().get(0).getContent());
//          for (String md5 : test.getContents().get(0).getLinkedFileHashes()) {
//              ArchivedFile aFile = ArchivedFile.getByMD5(md5).get();
//              msg.addFile(aFile.getFullName(), new ByteArrayInputStream(aFile.getData()));
//          }
//          for (ArchivedMessageAttachment attachment : test.getAttachments()) {
//              ArchivedFile aFile = ArchivedFile.getByMD5(attachment.getMD5()).get();
//              msg.addFile(attachment.getRawFileName() + "." + attachment.getFileExtension(), new ByteArrayInputStream(aFile.getData()));
//          }
//        };
//        message.getChannel().flatMap(channel -> channel.createMessage(spec)).block();

        return Mono.empty();
    }

    /**
     * Receive an updated message and save into SQL. If the message doesn't exist in SQL it will be created and flagged
     *  that the message update event was missed.
     *
     * @param event the even containing information about the edited message from discord
     * @return an empty mono
     */
    public static Mono<Void> receiveMessageUpdateEvent(MessageUpdateEvent event) {
        // If Discord has updated this message to include an embed then there's nothing for us to process
        if (!event.isContentChanged()) return Mono.empty();
        // Only handle events from guilds
        GuildChannel channel = event.getChannel().ofType(GuildChannel.class).block();
        if (channel == null) { return Mono.empty(); }
        // Ignore events from long enough ago that we do not retain them
        if (!retainEvent(event.getMessageId())) { return Mono.empty(); }

        // We should try and avoid the case where the bot doesn't have the message cached and doesn't have channel
        //  history permissions, we will get a 403 ClientException if that is the case.
        boolean havePermissions = channel
            .getEffectivePermissions(AudyClient.getClient().getSelfId())
            .map(permissions -> permissions.contains(Permission.READ_MESSAGE_HISTORY))
            .blockOptional().orElse(false);

        // In the event we don't have permissions to check channel history
        boolean haveMessage = event.getClient()
            .getGatewayResources()
            .getStateView()
            .getMessageStore()
            .find(event.getMessageId().asLong())
            .block() != null;

        // If we have the permissions to fetch, or have the message cached, then get the message.
        Message newMessage = (havePermissions || haveMessage) ? event.getMessage().block() : null;
        // getOld doesn't attempt to fetch the message on invocation.
        Message oldMessage = event.getOld().orElse(null);
        Optional<ArchivedMessage> archivedMessage = ArchivedMessage.getById(event.getMessageId().asLong());

        if (archivedMessage.isPresent()) {
            ArchivedMessage aMessage = archivedMessage.get();
            aMessage.lastSource = ArchivedMessageSource.MUE;
            if (newMessage != null) {
                if (oldMessage != null) {
                    // We don't record empty content, I think this should never happen and is always true?
                    if (!oldMessage.getContent().isEmpty()) {
                        // When we get the content, the final entry is always the latest entry
                        if (!aMessage.getContents()
                                .get(aMessage.getContents().size() - 1)
                                .getContent()
                                .equals(oldMessage.getContent())) {
                            // We're missing the previous content of the message. At this point, we have an sql entry for
                            //  the message so we did not miss either a MCE **or** a MUE. So we want to mark that we missed
                            //  an update event since there can be multiple MUEs but only one MCE.

                            // It's very unlikely that we will have cached a message after missing the previous event.
                            // It may be an interest to account for that possibility, however based on some loose estimates
                            //  message edits are very uncommon (like 10% compared to MCE), and are very often close to
                            //  when the message was created or when the message was edited previously. I don't think the
                            //  chances of this edge case are high enough to warrant covering it.
                            // Sources: ~~just trust be bro~~ I counted the events over a period of months on a server
                            //  I moderated. But that is a single server sample size, and less than 100 active users.
                            aMessage.messageFlags = ArchivedMessageFlags
                                    .addFlags(aMessage.messageFlags, ArchivedMessageFlags.MISSING_UPDATE);
                        }
                    }
                } else {
                    // Old message isn't cached, we missed it.
                    aMessage.messageFlags = ArchivedMessageFlags
                            .addFlags(aMessage.messageFlags, ArchivedMessageFlags.MISSING_UPDATE);
                }

                // We can now process the new message.
                // As of 2021/01/25 the only way I know a message can be edited to have empty content is if it is being
                //  deleted. We only need it present.

                // Cover the case where a message was uploaded with no content but with attachments,
                //  but then was edited to have content.
                aMessage.hasContent = true;
                // Unlike when a message is created, the required foreign keys are
                //  already present so we can create this immediately. And don't need to add it to aMessage.
                ArchivedMessageContent newContent = processMessageContent(newMessage);
                newContent.createNow();

                // Attachments cannot be edited after a message is posted. We can move to updating the ArchivedMessage.
                aMessage.updateNow();
            } else { // newMessage == null, aMessage is present
                // Missing the new message, not sure how this is possible asides from cache not being available.
                aMessage.messageFlags = ArchivedMessageFlags.addFlags(aMessage.getMessageFlags(), ArchivedMessageFlags.MISSING_UPDATE);
                aMessage.updateNow();
            }
        } else { // aMessage.isPresent() == false
            // If the new message is null then we do not need to know if we missed the old message. It's the same flag.
            if (newMessage != null) {
                // No message present in sql, it must be created and flagged.
                ArchivedMessage aMessage = createArchivedMessage(newMessage);
                aMessage.lastSource = ArchivedMessageSource.MUE;
                aMessage.messageFlags = ArchivedMessageFlags.of(ArchivedMessageFlags.MISSING_CREATE);
                aMessage.createNow();
            } else {
                // The new message should almost *always* be present from my understanding, we could get the channel ID
                //  and locate the guild ID from that but this edge case seems too rare to cover. This can also happen
                //  when channel history permissions are denied to the bot and the new message isn't cached. At that
                //  point it is a server moderator configuration error.
                // TODO: Send a message to the servers mod channel about this?
                logger.warn("Expected newMessage to be present for MUE! Message ID: " + event.getMessageId().asString());
            }
        }

        return Mono.empty();
    }

    /**
     * Mark a stored message as deleted.
     *
     * @param event the event for the deleted message from discord
     * @return an empty mono
     */
    public static Mono<Void> receiveMessageDeleteEvent(MessageDeleteEvent event) {
        // This would be very doable as a reactive chain, but it's mostly blocking SQL calls ...
        Optional<ArchivedMessage> amo = ArchivedMessage.getById(event.getMessageId().asLong());
        // Ignore events from long enough ago that we do not retain them
        if (!retainEvent(event.getMessageId())) { return Mono.empty(); }

        if (amo.isPresent()) {
            amo.get().deletedTimestamp = Instant.now().toEpochMilli();
            amo.get().updateNow();
        }

        // We don't bother accounting for if we didn't record the message, it's highly likely that the message
        //  isn't cached if it was deleted and we didn't receive a MCE or MUE for it. We must always record a
        //  guild ID with saved messages for privacy/security reasons. And an MDE does not have the guild ID.
        // The event may come with a channel ID, which could then get a guild ID. But this edge case isn't worth
        //  covering as we don't have the author ID which is also very important.

        return Mono.empty();
    }

    /**
     * Mark a list of messages as deleted.
     *
     * @param event the event for the deleted messages from discord
     * @return an empty mono
     */
    public static Mono<Void> receiveMessageBulkDeleteEvent(MessageBulkDeleteEvent event) {
        // See ArchivedMessageFactory#receiveMessageDeleteEvent() for notes, this is just a loop of that logic.
        Optional<ArchivedMessage> amo;
        long now = Instant.now().toEpochMilli();
        for (Snowflake id : event.getMessageIds()) {
            // Ignore messages from long enough ago that we do not retain them
            if (!retainEvent(id)) { continue; }
            amo = ArchivedMessage.getById(id.asLong());
            if (amo.isPresent()) {
                amo.get().deletedTimestamp = now;
                amo.get().updateNow();
            }
        }

        return Mono.empty();
    }

    /**
     * Create an ArchivedMessage that will be used to create data in sql repressing the message.
     * This should only be used when no message exists for the provided one in sql.
     *
     * @param message the message to extract attachments, links, and contents into an {@link ArchivedMessage} which
     *                can be stored in SQL.
     * @return a {@link ArchivedMessage} representing the provided message. {@link ArchivedMessage#createNow()} must
     *          be called after this method to created and stored it in SQL.
     */
    private static ArchivedMessage createArchivedMessage(Message message) {
        // Create new ArchivedMessage and save to SQL (required to add contents/attachments later)
        ArchivedMessage newMessage = new ArchivedMessage(message.getId().asLong(), message.getGuildId().get().asLong());
        newMessage.channelId = message.getChannelId().asLong();
        newMessage.authorId = message.getAuthor().get().getId().asLong();

        if (!message.getContent().isEmpty()) {
            newMessage.hasContent = true;
            newMessage.addContent(processMessageContent(message));
        }

        // Done with URLs and message content, create attachments
        for (Attachment attachment : message.getAttachments()) {
            // We don't need to run this through the regex matcher as we *know* it's a pure url
            String md5 = processUrl(attachment.getUrl());
            if (md5 != null) {
                newMessage.hasAttachments = true;
                newMessage.addAttachment(processMessageAttachment(message, attachment, md5));
            } else {
                // Something happened, the file should be downloadable. Log as warning and continue.
                // This may happen if users upload a file with no extension, or if it can't be accessed.
                logger.warn("Couldn't archive message attachment!\nMessage ID: " + message.getId().asString() +
                        "\nURL: " + attachment.getUrl());
            }
        }

        return newMessage;
    }

    /**
     * Evaluate a URL and potentially its contents to add them into sql.
     *
     * There are a few states that can exist here:
     *      tbl_file
     *      New File +      New URL (no entry)      : Row created in SQL
     *      New File +      New URL (existing entry): Not possible by design
     *      New File + Existing URL (existing entry): Not possible by Design
     * Existing File +      New URL (no entry)      : URL is added to SQL
     * Existing File +      New URL (existing entry): URL is added to SQL
     * Existing File + Existing URL (existing entry): No action taken, file is not checked due to design
     *
     * @param url the URL of the file we want to save to sql
     * @return the MD5 checksum of the linked file if it is valid for storage in sql, and is stored in sql, null otherwise
     */
    private static String processUrl(String url) {
        // Check for if we've already saved this URL
        Optional<ArchivedFile> aFile = ArchivedFile.getByUrl(url);
        if (!aFile.isPresent()) {
            // Link isn't present, download file and compare against known MD5s
            try {
                // Get the URL data if it is of a "media" type (image/audio/video)
                ByteArrayOutputStream baos = FileManager.downloadFile(url);
                if (baos != null) {
                    // Generate the MD5 and check database
                    byte[] data = baos.toByteArray();
                    String md5 = DigestUtils.md5Hex(data);

                    if (!ArchivedFile.md5Exists(md5)) {
                        // File doesn't exist in sql, add it
                        String fileName = Paths.get(new URL(url).getPath()).getFileName().toString();
                        String fileExt = "unknown";
                        int firstDotLoc = fileName.indexOf(".");
                        if (firstDotLoc > 0) {
                            fileExt = fileName.substring(firstDotLoc + 1);
                            fileName = fileName.substring(0, firstDotLoc);
                        }

                        // Create the file and the URL in SQL, we already know that neither exist
                        List<String> urls = new ArrayList<>();
                        urls.add(url);
                        new ArchivedFile(md5, fileName, fileExt, urls, data).createNow();
                    } else {
                        // The file exists, but this is a new link, we have the MD5 now
                        aFile = ArchivedFile.getByMD5(md5);
                        if (aFile.isPresent()) {
                            aFile.get().addUrl(url);
                            aFile.get().updateUrlsNow();
                        }
                    }

                    // File was a media file and was handled properly
                    return md5;
                }
            } catch (IOException ioe) {
                logger.debug(ioe.getClass().getCanonicalName() +
                    ": " + ioe.getMessage() +
                    " - Failed to download file from: " + url);
            }
        } else {
            // We already downloaded this url, return the MD5 of the file
            return aFile.get().getMD5();
        }

        // File wasn't a media file, or there was an IOException
        return null;
    }

    /**
     * Scan the content of a message for URLs which have valid downloadable files
     *
     * @param message the {@link Message} with the content to analyze
     * @return a newly created {@link ArchivedMessageContent} for the current message content
     */
    private static ArchivedMessageContent processMessageContent(Message message) {
        // First we need to replace all white space with a single space, remove extra spaces, then split by spaces
        // This also turns common characters used to prevent embedding and spoilering text into spaces
        // One serious caveat here, is that the | key can be in URLs from my understanding, but I don't think it's
        //  common enough for how often || is used for spoilers
        String[] terms = message.getContent().replaceAll("[\\s<>{}\\[\\]()|]+", " ").trim().split(" ");
        Set<String> validMD5s = new HashSet<>();

        for (String term : terms) {
            Matcher matcher = FileManager.urlRegex.matcher(term);
            if (matcher.matches()) {
                // Process this URL to add it and it's file to the database
                // We get group 2 as it is the full URL with no side tokens for discord spoiler/no embed
                String md5 = processUrl(matcher.group(2));
                if (md5 != null) {
                    validMD5s.add(md5);
                }
            }
        }

        // The ID is set to zero as a "shortcut" for getting the *original message contents*
        long timestamp = (message.getEditedTimestamp().isPresent())
                ? message.getEditedTimestamp().get().toEpochMilli() : 0L;
        // Create Message Contents, don't create contents as they must be created *after* the message
        // So the calling method must create this data
        return new ArchivedMessageContent(
            UUID.randomUUID().toString(),
            message.getId().asLong(),
            message.getContent(),
            timestamp,
            validMD5s);
    }

    /**
     * Create an ArchivedMessageAttachment representing the specified attachment.
     *
     * @param message the {@link Message} the {@link Attachment} belongs to.
     *                There is Attachment#getId() however the D4J docs are vague.
     * @param attachment the {@link Attachment} to extract data from to be stored in sql
     * @return a newly created {@link ArchivedMessageAttachment} for the attackment
     */
    private static ArchivedMessageAttachment processMessageAttachment(Message message, Attachment attachment, String md5) {
        // Parse filename and extension from attachment URL, which is far simpler than general URLs
        // We get the name directly from the attachment url, as this is the only way to reasonably
        //  preserve filenames based on user upload, we don't care too much if multiple links have
        //  different file names for the same file as the links are normally not created by the user.
        // Another way to put it, is we only care about the filename if it is what the user changed it to.
        int loc = attachment.getUrl().lastIndexOf("/");
        String fileName = attachment.getUrl().substring(loc + 1);
        String fileExt = "unknown";
        // Decided to do last index of instead of first, this avoids nonsense such as `filename.png.png`
        loc = fileName.lastIndexOf(".");
        if (loc != -1) {
            fileExt = fileName.substring(loc + 1);
            fileName = fileName.substring(0, loc);
        }
        if (attachment.isSpoiler()) {
            fileName = fileName.substring(Attachment.SPOILER_PREFIX.length() + 1);
        }
        // We don't do MD5 checks as we do want to store the file name/extension.
        return new ArchivedMessageAttachment(
            UUID.randomUUID().toString(),
            md5,
            message.getId().asLong(),
            attachment.isSpoiler(),
            fileName,
            fileExt);
    }
}
