/*
 * This file is a part of https://github.com/HunHage/Audy, also known as Audy
 *
 * Audy is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Audy is provided without any warranty, including any implied warranty.
 */

package net.exploitables.audy.data.history;

/**
 * This uses a property of binary numbers to store multiple flags as one number.
 * 0 = 0000, 1 = 0001, 2 = 0010, 4 = 0100, 8 = 1000, and so on.
 * So we can assign a 2^n value to each enum to represent what it is within the number.
 */
public enum ArchivedMessageFlags {
    MISSING_CREATE(3),  // Missing the MessageCreateEvent, this will always be activated with MISSING_UPDATE (1 + 2)
    MISSING_UPDATE(2),  // Missing one or more MessageUpdateEvents, this isn't always activated with MISSING_CREATE
    MISSING_DELETE(4);  // Missing one of the delete events that deleted this message

    int bitValue;
    ArchivedMessageFlags(int bit) {
        bitValue = bit;
    }

    /**
     * @param flags the flags to represent
     * @return an integer representing all flags
     */
    public static int of(ArchivedMessageFlags ... flags) {
        int f = 0;
        for (ArchivedMessageFlags flag : flags) {
            f += flag.bitValue;
        }
        return f;
    }

    /**
     * Add additional flags to the bitValue. This works by generating the bitValue of the flags to add
     *  then using a bitwise and statement to only flip the bits for those flags. Adding will corrupt the number.
     *
     * @param bitValue the integer representation of a set of flags
     * @param flags a list of flags to add to the bitValue
     * @return a new bitValue with the new flags included
     */
    public static int addFlags(int bitValue, ArchivedMessageFlags ... flags) {
        return bitValue & of(flags);
    }

    /**
     * Check if the provided bitValue has the specified flag.
     * This works by executing a bitwise and operation on the bitValue, which "masks" out the other bits.
     * All bits except for the one representing the flag are flipped to zero, effectively removing all other flags.
     * If the values are the same, then the flag is present.
     *
     * @param bitValue the integer representation of a group of enums
     * @param flag the flag to check if exists within the bitValue
     * @return true if the flag is present, false otherwise
     */
    public static boolean hasFlag(int bitValue, ArchivedMessageFlags flag) {
        return (bitValue & flag.bitValue) == flag.bitValue;
    }
}
