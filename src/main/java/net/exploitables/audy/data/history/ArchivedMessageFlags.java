package net.exploitables.audy.data.history;

/**
 * This uses a property of binary numbers to store multiple flags as one number.
 * 0 = 0000, 1 = 0001, 2 = 0010, 4 = 0100, 8 = 1000, and so on.
 * So we can assign a 2^n value to each enum to represent what it is within the number.
 */
public enum ArchivedMessageFlags {
    MISSING_CREATE(1), // Implied missing edit as well
    MISSING_DELETE(2);

    int bitValue;
    ArchivedMessageFlags(int bit) {
        bitValue = bit;
    }

    /**
     * @param flags the flags to represent
     * @return an integer of all flags
     */
    int of(ArchivedMessageFlags ... flags) {
        int f = 0;
        for (ArchivedMessageFlags flag : flags) {
            f += flag.bitValue;
        }
        return f;
    }

    /**
     *
     * @param bitValue the integer representation of a group of enums
     * @param flag the flag to check if exists within the bitValue
     * @return true if the flag is present, false otherwise
     */
    boolean hasFlag(int bitValue, ArchivedMessageFlags flag) {
        return (bitValue & flag.bitValue) == flag.bitValue;
    }
}
